using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Stardust.Generators;

/// <summary>
/// Generates code for multi-word (arbitrary-size) BitFields structs.
/// Uses full ulong words for bulk storage plus the smallest native type for the remainder,
/// producing byte-rounded struct sizes with [StructLayout(Sequential, Pack = 1)].
/// </summary>
internal static partial class BitFieldsMultiWordGenerator
{
    /// <summary>
    /// Maximum supported bit count for arbitrary-size bitfields (16,384 bits = 2,048 bytes = 256 ulongs).
    /// </summary>
    public const int MAX_BIT_COUNT = 16384;

    /// <summary>
    /// Generates the complete source for a multi-word BitFields struct.
    /// </summary>
    public static void Execute(SourceProductionContext context, BitFieldsInfo info)
    {
        var layout = new WordLayout(info.TotalBits);
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by Stardust.Generators source generator.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS0675");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Globalization;");
        sb.AppendLine("using System.Numerics;");
        sb.AppendLine("using System.Buffers.Binary;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine("using Stardust.Utilities;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(info.Namespace))
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        // Open containing types
        int indentLevel = 0;
        foreach (var (kind, name, accessibility) in info.ContainingTypes)
        {
            sb.AppendLine($"{Ind(indentLevel)}{accessibility} partial {kind} {name}");
            sb.AppendLine($"{Ind(indentLevel)}{{");
            indentLevel++;
        }

        string ind = Ind(indentLevel);
        string mind = Ind(indentLevel + 1);
        string t = info.TypeName;
        int wc = layout.WordCount;

        // StructLayout to prevent padding after smaller trailing word
        sb.AppendLine($"{ind}[StructLayout(LayoutKind.Sequential, Pack = 1)]");
        sb.AppendLine($"{ind}[JsonConverter(typeof({t}JsonConverter))]");
        sb.AppendLine($"{ind}{info.Accessibility} partial struct {t} : IComparable, IComparable<{t}>, IEquatable<{t}>,");
        sb.AppendLine($"{ind}                             IFormattable, ISpanFormattable, IParsable<{t}>, ISpanParsable<{t}>");
        sb.AppendLine($"{ind}{{");

        // Word fields
        for (int i = 0; i < wc; i++)
        {
            int lo = i * 64;
            int hi = System.Math.Min(lo + (layout.IsRemainder(i) ? layout.RemainderBits - 1 : 63), info.TotalBits - 1);
            sb.AppendLine($"{mind}private {layout.FieldType(i)} _w{i}; // bits {lo}-{hi}");
        }
        sb.AppendLine();
        sb.AppendLine($"{mind}/// <summary>Number of conceptual words in the backing store.</summary>");
        sb.AppendLine($"{mind}private const int WordCount = {wc};");
        sb.AppendLine();
        sb.AppendLine($"{mind}/// <summary>Total number of defined bits.</summary>");
        sb.AppendLine($"{mind}private const int TotalBits = {info.TotalBits};");
        sb.AppendLine();
        sb.AppendLine($"{mind}/// <summary>Size of this struct in bytes.</summary>");
        sb.AppendLine($"{mind}public const int SizeInBytes = {layout.StructBytes};");
        sb.AppendLine();

        // Last-word mask
        int lwBits = info.TotalBits % 64;
        if (lwBits == 0) lwBits = 64;
        ulong lastWordMask = lwBits == 64 ? ulong.MaxValue : (1UL << lwBits) - 1;
        sb.AppendLine($"{mind}private const ulong LastWordMask = 0x{lastWordMask:X16}UL;");
        sb.AppendLine();
        sb.AppendLine($"{mind}/// <summary>Returns a {t} with all bits set to zero.</summary>");
        sb.AppendLine($"{mind}public static {t} Zero => default;");
        sb.AppendLine();

        GenerateConstructors(sb, info, layout, mind);

        foreach (var field in info.Fields)
            GenerateBitFieldProperty(sb, info, layout, field, mind);
        foreach (var flag in info.Flags)
            GenerateBitFlagProperty(sb, info, layout, flag, mind);
        foreach (var flag in info.Flags)
            GenerateStaticBitProperty(sb, info, layout, flag, mind);
        foreach (var field in info.Fields)
            GenerateStaticMaskProperty(sb, info, layout, field, mind);
        foreach (var flag in info.Flags)
            GenerateWithFlagMethod(sb, info, layout, flag, mind);
        foreach (var field in info.Fields)
            GenerateWithFieldMethod(sb, info, layout, field, mind);

        GenerateMultiWordFieldMetadata(sb, info, mind);

        GenerateBitwiseOperators(sb, info, layout, mind);
        GenerateArithmeticOperators(sb, info, layout, mind);
        GenerateShiftOperators(sb, info, layout, mind);
        GenerateComparisonOperators(sb, info, layout, mind);
        GenerateEqualityOperators(sb, info, layout, mind);
        GenerateConversions(sb, info, layout, mind);
        GenerateBigIntegerHelpers(sb, info, layout, mind);
        GenerateByteSpanMethods(sb, info, layout, mind);
        GenerateParsingMethods(sb, info, mind);
        GenerateFormattingMethods(sb, info, layout, mind);
        GenerateComparisonMethods(sb, info, layout, mind);
        GenerateJsonConverter(sb, info, mind);

        sb.AppendLine($"{ind}}}");

        for (int i = info.ContainingTypes.Count - 1; i >= 0; i--)
        {
            indentLevel--;
            sb.AppendLine($"{Ind(indentLevel)}}}");
        }

        string fileName = info.ContainingTypes.Count > 0
            ? $"{string.Join("_", info.ContainingTypes.Select(ct => ct.Name))}_{t}.g.cs"
            : $"{t}.g.cs";

        context.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string Ind(int level) => new string(' ', level * 4);

    /// <summary>
    /// Generates a static <c>Fields</c> property for multi-word structs,
    /// reusing the same <c>BitFieldInfo</c> metadata format as single-word and view types.
    /// </summary>
    private static void GenerateMultiWordFieldMetadata(StringBuilder sb, BitFieldsInfo info, string ind)
    {
        string structByteOrder = info.ByteOrder == ByteOrderValue.BigEndian
            ? "ByteOrder.BigEndian" : "ByteOrder.LittleEndian";
        string structBitOrder = "BitOrder.BitZeroIsLsb";

        sb.AppendLine($"{ind}/// <summary>Metadata for every field and flag declared on this struct, in declaration order.</summary>");
        sb.AppendLine($"{ind}public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]");
        sb.AppendLine($"{ind}{{");

        foreach (var f in info.DeclaredFields)
        {
            var qualifiedType = f.PropertyType.StartsWith("global::") ? f.PropertyType.Substring("global::".Length) : f.PropertyType;
            var descArgs = FormatDescriptionArgs(f.Description, f.DescriptionResourceType, qualifiedType);
            sb.AppendLine($"{ind}    new(\"{f.Name}\", {f.Shift}, {f.Width}, \"{qualifiedType}\", false, {structByteOrder}, {structBitOrder}{descArgs}),");
        }

        foreach (var f in info.DeclaredFlags)
        {
            var descArgs = FormatDescriptionArgs(f.Description, f.DescriptionResourceType, null);
            sb.AppendLine($"{ind}    new(\"{f.Name}\", {f.Bit}, 1, \"bool\", true, {structByteOrder}, {structBitOrder}{descArgs}),");
        }

        sb.AppendLine($"{ind}}};");
        sb.AppendLine();
    }

    private static string FormatDescriptionArgs(string? description, string? descriptionResourceType, string? _)
    {
        if (description is null)
            return "";

        var escaped = description.Replace("\\", "\\\\").Replace("\"", "\\\"");
        if (descriptionResourceType is null)
            return $", \"{escaped}\"";

        var resType = descriptionResourceType.StartsWith("global::") ? descriptionResourceType.Substring("global::".Length) : descriptionResourceType;
        return $", \"{escaped}\", typeof({resType})";
    }

    /// <summary>
    /// Describes the hybrid word layout: full ulongs + smallest trailing native type.
    /// </summary>
    private sealed class WordLayout
    {
        public int TotalBits { get; }
        public int WordCount { get; }
        public int FullUlongCount { get; }
        public bool HasRemainder { get; }
        public string RemainderType { get; }
        public int RemainderBits { get; }
        public int StructBytes { get; }

        public WordLayout(int totalBits)
        {
            TotalBits = totalBits;
            FullUlongCount = totalBits / 64;
            RemainderBits = totalBits % 64;
            HasRemainder = RemainderBits > 0;
            if (HasRemainder)
            {
                int remBytes = (RemainderBits + 7) / 8;
                RemainderType = remBytes <= 1 ? "byte"
                    : remBytes <= 2 ? "ushort"
                    : remBytes <= 4 ? "uint"
                    : "ulong";
                WordCount = FullUlongCount + 1;
                StructBytes = FullUlongCount * 8 + remBytes;
            }
            else
            {
                RemainderType = "ulong";
                WordCount = FullUlongCount;
                StructBytes = FullUlongCount * 8;
            }
        }

        /// <summary>Returns true if word i is the smaller remainder word.</summary>
        public bool IsRemainder(int i) => HasRemainder && i == WordCount - 1;

        /// <summary>Returns the C# type for word at index i.</summary>
        public string FieldType(int i) => IsRemainder(i) ? RemainderType : "ulong";

        /// <summary>Returns expression to read word i as ulong (with cast if needed).</summary>
        public string Read(string prefix, int i)
            => IsRemainder(i) ? $"((ulong){prefix}_w{i})" : $"{prefix}_w{i}";

        /// <summary>Returns expression to store a ulong result into word i (with truncation if needed).</summary>
        public string Store(int i, string expr)
            => IsRemainder(i) ? $"({RemainderType})({expr})" : expr;

        /// <summary>Formats a literal value for word i with the correct suffix/cast.</summary>
        public string Literal(int i, ulong value)
        {
            if (!IsRemainder(i))
                return value == 0 ? "0UL" : $"0x{value:X}UL";
            if (value == 0)
                return $"default({RemainderType})";
            return RemainderType switch
            {
                "byte" => $"(byte)0x{(byte)value:X}",
                "ushort" => $"(ushort)0x{(ushort)value:X}",
                "uint" => $"0x{(uint)value:X}U",
                _ => $"0x{value:X}UL",
            };
        }

        /// <summary>Returns the default zero value for word i.</summary>
        public string Zero(int i) => Literal(i, 0);

        /// <summary>Maximum word count for which a full-word positional constructor is generated.</summary>
        public const int MAX_CONSTRUCTOR_WORDS = 4;

        /// <summary>True if the type has a positional constructor accepting all words.</summary>
        public bool HasFullConstructor => WordCount <= MAX_CONSTRUCTOR_WORDS;
    }

    /// <summary>
    /// Returns an inline <c>new(expr0, expr1, ...)</c> expression for ?4 word types.
    /// For >4 words, returns null — caller must use <see cref="EmitBlockConstruction"/>.
    /// </summary>
    private static string? InlineNew(WordLayout layout, string[] wordExprs)
    {
        if (!layout.HasFullConstructor) return null;
        return $"new({string.Join(", ", wordExprs)})";
    }

    /// <summary>
    /// Emits a multi-line block: var result = default(T); result._w0 = expr; ... return result;
    /// Used for types with >4 words where no positional constructor exists.
    /// </summary>
    private static void EmitBlockConstruction(StringBuilder sb, string typeName, WordLayout layout, string ind, string[] wordExprs)
    {
        sb.AppendLine($"{ind}var result = default({typeName});");
        for (int i = 0; i < layout.WordCount; i++)
            sb.AppendLine($"{ind}result._w{i} = {wordExprs[i]};");
        sb.AppendLine($"{ind}return result;");
    }

    /// <summary>
    /// Emits either an inline <c>=> new(...)</c> or a block body, depending on word count.
    /// For expression-bodied operators/methods that need to return a constructed value.
    /// </summary>
    private static void EmitReturnConstruction(StringBuilder sb, string typeName, WordLayout layout, string ind, string[] wordExprs)
    {
        var inline = InlineNew(layout, wordExprs);
        if (inline != null)
        {
            sb.AppendLine($"{ind}return {inline};");
        }
        else
        {
            EmitBlockConstruction(sb, typeName, layout, ind, wordExprs);
        }
    }

    /// <summary>
    /// Returns a descriptive parameter name for word index i out of wc total words.
    /// Names indicate significance rather than offset to avoid endianness confusion.
    /// </summary>
    private static string WordParamName(int i, int wc) => wc switch
    {
        1 => "value",
        2 => i == 0 ? "lower" : "upper",
        3 => i switch { 0 => "lower", 1 => "middle", _ => "upper" },
        4 => i switch { 0 => "lower", 1 => "midLower", 2 => "midUpper", _ => "upper" },
        _ => $"w{i}" // fallback (shouldn't happen, constructor only generated for <=4 words)
    };

    private static void GenerateConstructors(StringBuilder sb, BitFieldsInfo info, WordLayout layout, string ind)
    {
        int wc = layout.WordCount;
        int lwBits = layout.RemainderBits > 0 ? layout.RemainderBits : 64;
        bool mustMaskLast = lwBits < (layout.IsRemainder(wc - 1)
            ? (layout.RemainderType == "byte" ? 8 : layout.RemainderType == "ushort" ? 16 : layout.RemainderType == "uint" ? 32 : 64)
            : 64);

        // Full word constructor - only for ≤4 words (beyond that, use span or fluent API)
        if (wc <= 4)
        {
            var paramList = string.Join(", ", Enumerable.Range(0, wc).Select(i =>
                $"{layout.FieldType(i)} {WordParamName(i, wc)}"));

            sb.AppendLine($"{ind}/// <summary>Creates a new {info.TypeName} from individual word values.</summary>");
            for (int i = 0; i < wc; i++)
            {
                int lo = i * 64;
                int hi = System.Math.Min(lo + (layout.IsRemainder(i) ? layout.RemainderBits - 1 : 63), info.TotalBits - 1);
                string sig = i == 0 ? "least significant" : i == wc - 1 ? "most significant" : "";
                string suffix = sig.Length > 0 ? $" ({sig})" : "";
                sb.AppendLine($"{ind}/// <param name=\"{WordParamName(i, wc)}\">Bits {lo}-{hi}{suffix}.</param>");
            }
            sb.AppendLine($"{ind}public {info.TypeName}({paramList})");
            sb.AppendLine($"{ind}{{");
            for (int i = 0; i < wc; i++)
            {
                string pn = WordParamName(i, wc);
                bool isLast = i == wc - 1;
                if (isLast && mustMaskLast && info.UndefinedBitsMode == MustBeValue.Zero)
                    sb.AppendLine($"{ind}    _w{i} = {layout.Store(i, $"(ulong){pn} & LastWordMask")};");
                else if (isLast && mustMaskLast && info.UndefinedBitsMode == MustBeValue.One)
                    sb.AppendLine($"{ind}    _w{i} = {layout.Store(i, $"(ulong){pn} | ~LastWordMask")};");
                else
                    sb.AppendLine($"{ind}    _w{i} = {pn};");
            }
            sb.AppendLine($"{ind}}}");
            sb.AppendLine();
        }

        // Single ulong constructor (zero-extends)
        if (wc <= 4)
        {
            var trailingDefaults = string.Join("", Enumerable.Range(1, wc - 1).Select(i => $", {layout.Zero(i)}"));
            sb.AppendLine($"{ind}/// <summary>Creates a new {info.TypeName} from a ulong value (zero-extended).</summary>");
            sb.AppendLine($"{ind}public {info.TypeName}(ulong value) : this(value{trailingDefaults}) {{ }}");
        }
        else
        {
            sb.AppendLine($"{ind}/// <summary>Creates a new {info.TypeName} from a ulong value (zero-extended).</summary>");
            sb.AppendLine($"{ind}public {info.TypeName}(ulong value)");
            sb.AppendLine($"{ind}{{");
            sb.AppendLine($"{ind}    this = default;");
            sb.AppendLine($"{ind}    _w0 = value;");
            sb.AppendLine($"{ind}}}");
        }
        sb.AppendLine();

        // Int constructor - sign extends to all words (e.g., -1 sets all bits to 1)
        sb.AppendLine($"{ind}/// <summary>Creates a new {info.TypeName} from an int value. Negative values are sign-extended");
        sb.AppendLine($"{ind}/// to all {info.TotalBits} bits (e.g., -1 sets all bits to 1).</summary>");
        sb.AppendLine($"{ind}public {info.TypeName}(int value)");
        sb.AppendLine($"{ind}{{");
        sb.AppendLine($"{ind}    ulong extended = unchecked((ulong)(long)value);");
        sb.AppendLine($"{ind}    ulong fill = value < 0 ? ulong.MaxValue : 0UL;");
        sb.AppendLine($"{ind}    _w0 = extended;");
        for (int i = 1; i < wc; i++)
        {
            bool isLast = i == wc - 1;
            if (isLast && mustMaskLast && info.UndefinedBitsMode == MustBeValue.Zero)
                sb.AppendLine($"{ind}    _w{i} = {layout.Store(i, "fill & LastWordMask")};");
            else if (isLast && mustMaskLast && info.UndefinedBitsMode == MustBeValue.One)
                sb.AppendLine($"{ind}    _w{i} = {layout.Store(i, "fill | ~LastWordMask")};");
            else
                sb.AppendLine($"{ind}    _w{i} = {layout.Store(i, "fill")};");
        }
        sb.AppendLine($"{ind}}}");
        sb.AppendLine();
    }
}
