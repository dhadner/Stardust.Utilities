using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Stardust.Utilities.Generators
{
    /// <summary>
    /// Source generator that creates bitfield property implementations from attributes.
    /// Requires the Stardust.Utilities.BitFieldsAttribute, Stardust.Utilities.BitFieldAttribute, and Stardust.Utilities.BitFlagAttribute
    /// to be defined in the consuming project (provided by Stardust.Utilities.BitFieldAttributes.cs).
    /// </summary>
    [Generator]
    public class BitFieldsGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all structs with [BitFields] attribute
            var structDeclarations = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    "Stardust.Utilities.BitFieldsAttribute",
                    predicate: static (node, _) => node is StructDeclarationSyntax,
                    transform: static (ctx, _) => GetBitFieldsInfo(ctx))
                .Where(static info => info is not null);

            // Generate source for each
            context.RegisterSourceOutput(structDeclarations,
                static (spc, info) => Execute(spc, info!));
        }

        private static BitFieldsInfo? GetBitFieldsInfo(GeneratorAttributeSyntaxContext context)
        {
            if (context.TargetSymbol is not INamedTypeSymbol structSymbol)
                return null;

            var structSyntax = (StructDeclarationSyntax)context.TargetNode;

            // Find the Value field/property and its type
            var valueProperty = structSymbol.GetMembers("Value")
                .OfType<IPropertySymbol>()
                .FirstOrDefault();

            var valueField = structSymbol.GetMembers("Value")
                .OfType<IFieldSymbol>()
                .FirstOrDefault();

            string? storageType = valueProperty?.Type.ToDisplayString()
                ?? valueField?.Type.ToDisplayString();

            if (storageType is null)
                return null;

            // Determine the non-generic def type based on storage
            string defSuffix = storageType switch
            {
                "byte" => "8",
                "ushort" => "16",
                "uint" => "32",
                "ulong" => "64",
                _ => "64" // Default to 64-bit for other types
            };

            var fields = new List<BitFieldInfo>();

            // Find all properties with BitFlag or BitField attributes
            foreach (var member in structSymbol.GetMembers().OfType<IPropertySymbol>())
            {
                foreach (var attr in member.GetAttributes())
                {
                    if (attr.AttributeClass?.Name == "BitFlagAttribute" &&
                        attr.ConstructorArguments.Length >= 1)
                    {
                        int bit = (int)attr.ConstructorArguments[0].Value!;
                        fields.Add(new BitFieldInfo(member.Name, "bool", bit, 1, true));
                    }
                    else if (attr.AttributeClass?.Name == "BitFieldAttribute" &&
                             attr.ConstructorArguments.Length >= 2)
                    {
                        int shift = (int)attr.ConstructorArguments[0].Value!;
                        int width = (int)attr.ConstructorArguments[1].Value!;
                        string fieldType = member.Type.ToDisplayString();
                        fields.Add(new BitFieldInfo(member.Name, fieldType, shift, width, false));
                    }
                }
            }

            if (fields.Count == 0)
                return null;

            string? namespaceName = structSymbol.ContainingNamespace.IsGlobalNamespace
                ? null
                : structSymbol.ContainingNamespace.ToDisplayString();

            return new BitFieldsInfo(
                structSymbol.Name,
                namespaceName,
                storageType,
                defSuffix,
                fields,
                structSyntax.Modifiers.Any(SyntaxKind.PublicKeyword));
        }

        private static void Execute(SourceProductionContext context, BitFieldsInfo info)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using Stardust.Utilities;");
            sb.AppendLine();

            if (info.Namespace is not null)
            {
                sb.AppendLine($"namespace {info.Namespace}");
                sb.AppendLine("{");
            }

            string indent = info.Namespace is not null ? "    " : "";
            string accessibility = info.IsPublic ? "public" : "internal";

            sb.AppendLine($"{indent}{accessibility} partial struct {info.StructName}");
            sb.AppendLine($"{indent}{{");

            // Generate static field definitions
            foreach (var field in info.Fields)
            {
                if (field.IsFlag)
                {
                    sb.AppendLine($"{indent}    private static readonly BitFlagDef{info.DefSuffix} _{ToCamelCase(field.Name)}Def = new({field.Shift});");
                }
                else
                {
                    sb.AppendLine($"{indent}    private static readonly BitFieldDef{info.DefSuffix} _{ToCamelCase(field.Name)}Def = new({field.Shift}, {field.Width});");
                }
            }

            sb.AppendLine();

            // Generate properties (implementing declarations for partial properties)
            foreach (var field in info.Fields)
            {
                string defName = $"_{ToCamelCase(field.Name)}Def";

                if (field.IsFlag)
                {
                    sb.AppendLine($"{indent}    public partial bool {field.Name}");
                    sb.AppendLine($"{indent}    {{");
                    sb.AppendLine($"{indent}        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.AppendLine($"{indent}        get => {defName}.IsSet(Value);");
                    sb.AppendLine($"{indent}        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.AppendLine($"{indent}        set => Value = {defName}.Set(Value, value);");
                    sb.AppendLine($"{indent}    }}");
                }
                else
                {
                    string getMethod = field.FieldType switch
                    {
                        "byte" => "GetByte",
                        "ushort" => "GetUShort",
                        "uint" => "GetUInt",
                        "ulong" => "GetULong",
                        _ => "GetByte"
                    };

                    sb.AppendLine($"{indent}    public partial {field.FieldType} {field.Name}");
                    sb.AppendLine($"{indent}    {{");
                    sb.AppendLine($"{indent}        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.AppendLine($"{indent}        get => {defName}.{getMethod}(Value);");
                    sb.AppendLine($"{indent}        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                    sb.AppendLine($"{indent}        set => Value = {defName}.Set(Value, value);");
                    sb.AppendLine($"{indent}    }}");
                }

                sb.AppendLine();
            }

            // Generate implicit conversion operators
            sb.AppendLine($"{indent}    // Implicit conversion operators");
            sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"{indent}    public static implicit operator {info.StorageType}({info.StructName} r) => r.Value;");
            sb.AppendLine();
            sb.AppendLine($"{indent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"{indent}    public static implicit operator {info.StructName}({info.StorageType} v) => new() {{ Value = v }};");

            sb.AppendLine($"{indent}}}");

            if (info.Namespace is not null)
            {
                sb.AppendLine("}");
            }

            context.AddSource($"{info.StructName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static string ToCamelCase(string name)
        {
            if (string.IsNullOrEmpty(name))
                return name;
            return char.ToLowerInvariant(name[0]) + name.Substring(1);
        }
    }

    internal sealed class BitFieldsInfo
    {
        public string StructName { get; }
        public string? Namespace { get; }
        public string StorageType { get; }
        public string DefSuffix { get; }
        public List<BitFieldInfo> Fields { get; }
        public bool IsPublic { get; }

        public BitFieldsInfo(string structName, string? ns, string storageType, string defSuffix, List<BitFieldInfo> fields, bool isPublic)
        {
            StructName = structName;
            Namespace = ns;
            StorageType = storageType;
            DefSuffix = defSuffix;
            Fields = fields;
            IsPublic = isPublic;
        }
    }

    internal sealed class BitFieldInfo
    {
        public string Name { get; }
        public string FieldType { get; }
        public int Shift { get; }
        public int Width { get; }
        public bool IsFlag { get; }

        public BitFieldInfo(string name, string fieldType, int shift, int width, bool isFlag)
        {
            Name = name;
            FieldType = fieldType;
            Shift = shift;
            Width = width;
            IsFlag = isFlag;
        }
    }
}
