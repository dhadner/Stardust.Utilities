using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Stardust.Generators;

/// <summary>
/// Source generator for [BitFields] attributed structs.
/// This generator is a FALLBACK - it generates code that the disk-based tool would create.
/// The disk-based tool creates .Generated.cs files that are committed to Git.
/// If those files exist, they are compiled directly and this generator's output is unused.
/// </summary>
[Generator]
public class BitFieldsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all structs with [BitFields] attribute
        var structDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Stardust.Utilities.BitFieldsAttribute",
                predicate: static (node, _) => node is StructDeclarationSyntax,
                transform: static (ctx, _) => GetBitFieldsInfo(ctx))
            .Where(static info => info is not null);

        // Generate source for each
        context.RegisterSourceOutput(structDeclarations,
            static (spc, info) => Execute(spc, info!));
    }

    private static BitFieldsInfo? GetBitFieldsInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol structSymbol)
            return null;

        // Find Value field/property and its type
        string? storageType = null;
        foreach (var member in structSymbol.GetMembers())
        {
            if (member is IFieldSymbol field && field.Name == "Value")
            {
                storageType = field.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                break;
            }
            if (member is IPropertySymbol prop && prop.Name == "Value")
            {
                storageType = prop.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                break;
            }
        }

        if (storageType == null)
            return null;

        var fields = new List<BitFieldInfo>();
        var flags = new List<BitFlagInfo>();

        foreach (var member in structSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            foreach (var attr in member.GetAttributes())
            {
                var attrName = attr.AttributeClass?.Name;
                if (attrName == "BitFieldAttribute" && attr.ConstructorArguments.Length >= 2)
                {
                    var shift = attr.ConstructorArguments[0].Value?.ToString() ?? "0";
                    var width = attr.ConstructorArguments[1].Value?.ToString() ?? "1";
                    var propType = member.Type.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
                    fields.Add(new BitFieldInfo(member.Name, propType, shift, width));
                }
                else if (attrName == "BitFlagAttribute" && attr.ConstructorArguments.Length >= 1)
                {
                    var bit = attr.ConstructorArguments[0].Value?.ToString() ?? "0";
                    flags.Add(new BitFlagInfo(member.Name, bit));
                }
            }
        }

        if (fields.Count == 0 && flags.Count == 0)
            return null;

        var ns = structSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : structSymbol.ContainingNamespace.ToDisplayString();

        return new BitFieldsInfo(
            structSymbol.Name,
            ns,
            GetAccessibility(structSymbol),
            storageType,
            fields,
            flags);
    }

    private static string GetAccessibility(ISymbol symbol)
    {
        return symbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            _ => "public"
        };
    }

    private static void Execute(SourceProductionContext context, BitFieldsInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by Stardust.Generators (fallback source generator).");
        sb.AppendLine("// For better IntelliSense, run the tool to create .Generated.cs files and commit them.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(info.Namespace))
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        var defType = info.StorageType switch
        {
            "byte" => "8",
            "ushort" => "16",
            "uint" => "32",
            "ulong" => "64",
            _ => "32"
        };

        sb.AppendLine($"{info.Accessibility} partial struct {info.TypeName}");
        sb.AppendLine("{");

        // Generate static field definitions
        foreach (var field in info.Fields)
        {
            sb.AppendLine($"    private static readonly Stardust.Utilities.BitFieldDef{defType} _{field.Name}Def = new({field.Shift}, {field.Width});");
        }
        foreach (var flag in info.Flags)
        {
            sb.AppendLine($"    private static readonly Stardust.Utilities.BitFlagDef{defType} _{flag.Name}Def = new({flag.Bit});");
        }
        sb.AppendLine();

        // Generate property implementations
        foreach (var field in info.Fields)
        {
            var extractMethod = field.PropertyType switch
            {
                "byte" => "GetByte",
                "ushort" => "GetUShort",
                "uint" => "GetUInt",
                "ulong" => "GetULong",
                _ => "GetByte"
            };

            sb.AppendLine($"    public partial {field.PropertyType} {field.Name}");
            sb.AppendLine("    {");
            sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        get => _{field.Name}Def.{extractMethod}(Value);");
            sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        set => Value = _{field.Name}Def.Set(Value, value);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        foreach (var flag in info.Flags)
        {
            sb.AppendLine($"    public partial bool {flag.Name}");
            sb.AppendLine("    {");
            sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        get => _{flag.Name}Def.IsSet(Value);");
            sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        set => Value = _{flag.Name}Def.Set(Value, value);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // Generate implicit conversions
        sb.AppendLine($"    public static implicit operator {info.StorageType}({info.TypeName} value) => value.Value;");
        sb.AppendLine($"    public static implicit operator {info.TypeName}({info.StorageType} value) => new() {{ Value = value }};");

        sb.AppendLine("}");

        context.AddSource($"{info.TypeName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}

#region Info Classes

internal sealed class BitFieldsInfo
{
    public string TypeName { get; }
    public string? Namespace { get; }
    public string Accessibility { get; }
    public string StorageType { get; }
    public List<BitFieldInfo> Fields { get; }
    public List<BitFlagInfo> Flags { get; }

    public BitFieldsInfo(string typeName, string? ns, string accessibility, string storageType, List<BitFieldInfo> fields, List<BitFlagInfo> flags)
    {
        TypeName = typeName;
        Namespace = ns;
        Accessibility = accessibility;
        StorageType = storageType;
        Fields = fields;
        Flags = flags;
    }
}

internal sealed class BitFieldInfo
{
    public string Name { get; }
    public string PropertyType { get; }
    public string Shift { get; }
    public string Width { get; }

    public BitFieldInfo(string name, string propertyType, string shift, string width)
    {
        Name = name;
        PropertyType = propertyType;
        Shift = shift;
        Width = width;
    }
}

internal sealed class BitFlagInfo
{
    public string Name { get; }
    public string Bit { get; }

    public BitFlagInfo(string name, string bit)
    {
        Name = name;
        Bit = bit;
    }
}

#endregion
