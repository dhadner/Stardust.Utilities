// <auto-generated>
// This code was generated by Stardust.Utilities.Tool.
// Changes to code inside #region blocks will be overwritten.
// Add custom code outside the #region blocks.
// </auto-generated>

#nullable enable
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace Stardust.Utilities.Test;

public readonly partial struct TestCommand : IEquatable<TestCommand>
{
    #region Generated Code - Do Not Modify

    private readonly Kind _tag;
    private readonly (uint, int) _setValuePayload;
    private readonly Breakpoint? _setBreakpointPayload;
    private readonly string? _evaluatePayload;

    /// <summary>Gets the discriminant tag indicating which variant this is.</summary>
    public Kind Tag => _tag;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TestCommand(Kind tag, (uint, int) setValuePayload, Breakpoint? setBreakpointPayload, string? evaluatePayload)
    {
        _tag = tag;
        _setValuePayload = setValuePayload;
        _setBreakpointPayload = setBreakpointPayload;
        _evaluatePayload = evaluatePayload;
    }

    /// <summary>Creates a SetValue variant.</summary>
    /// <param name="value">The payload value.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TestCommand SetValue((uint, int) value) => new(Kind.SetValue, value, default, default);

    /// <summary>Creates a SetBreakpoint variant.</summary>
    /// <param name="value">The payload value.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TestCommand SetBreakpoint(Breakpoint value) => new(Kind.SetBreakpoint, default, value, default);

    /// <summary>Creates a Evaluate variant.</summary>
    /// <param name="value">The payload value.</param>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TestCommand Evaluate(string value) => new(Kind.Evaluate, default, default, value);

    /// <summary>Creates a Step variant.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TestCommand Step() => new(Kind.Step, default, default, default);

    /// <summary>Creates a Continue variant.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TestCommand Continue() => new(Kind.Continue, default, default, default);

    /// <summary>Returns true if this is the SetValue variant.</summary>
    public bool IsSetValue => _tag == Kind.SetValue;

    /// <summary>Returns true if this is the SetBreakpoint variant.</summary>
    public bool IsSetBreakpoint => _tag == Kind.SetBreakpoint;

    /// <summary>Returns true if this is the Evaluate variant.</summary>
    public bool IsEvaluate => _tag == Kind.Evaluate;

    /// <summary>Returns true if this is the Step variant.</summary>
    public bool IsStep => _tag == Kind.Step;

    /// <summary>Returns true if this is the Continue variant.</summary>
    public bool IsContinue => _tag == Kind.Continue;

    /// <summary>Attempts to get the SetValue payload.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetSetValue(out (uint, int) value)
    {
        if (_tag == Kind.SetValue)
        {
            value = _setValuePayload;
            return true;
        }
        value = default!;
        return false;
    }

    /// <summary>Attempts to get the SetBreakpoint payload.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetSetBreakpoint(out Breakpoint value)
    {
        if (_tag == Kind.SetBreakpoint)
        {
            value = _setBreakpointPayload!;
            return true;
        }
        value = default!;
        return false;
    }

    /// <summary>Attempts to get the Evaluate payload.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryGetEvaluate(out string value)
    {
        if (_tag == Kind.Evaluate)
        {
            value = _evaluatePayload!;
            return true;
        }
        value = default!;
        return false;
    }

    /// <summary>Exhaustively matches all variants and returns a result.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TResult Match<TResult>(
        Func<(uint, int), TResult> SetValue,
        Func<Breakpoint, TResult> SetBreakpoint,
        Func<string, TResult> Evaluate,
        Func<TResult> Step,
        Func<TResult> @Continue)
    {
        return _tag switch
        {
            Kind.SetValue => SetValue(_setValuePayload),
            Kind.SetBreakpoint => SetBreakpoint(_setBreakpointPayload!),
            Kind.Evaluate => Evaluate(_evaluatePayload!),
            Kind.Step => Step(),
            Kind.Continue => @Continue(),
            _ => throw new InvalidOperationException($"Unknown tag: {_tag}")
        };
    }

    /// <summary>Exhaustively matches all variants and performs an action.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Match(
        Action<(uint, int)> SetValue,
        Action<Breakpoint> SetBreakpoint,
        Action<string> Evaluate,
        Action Step,
        Action @Continue)
    {
        switch (_tag)
        {
            case Kind.SetValue: SetValue(_setValuePayload); break;
            case Kind.SetBreakpoint: SetBreakpoint(_setBreakpointPayload!); break;
            case Kind.Evaluate: Evaluate(_evaluatePayload!); break;
            case Kind.Step: Step(); break;
            case Kind.Continue: @Continue(); break;
        }
    }

    /// <inheritdoc/>
    public bool Equals(TestCommand other)
    {
        if (_tag != other._tag) return false;
        return _tag switch
        {
            Kind.SetValue => EqualityComparer<(uint, int)>.Default.Equals(_setValuePayload, other._setValuePayload),
            Kind.SetBreakpoint => EqualityComparer<Breakpoint>.Default.Equals(_setBreakpointPayload, other._setBreakpointPayload),
            Kind.Evaluate => EqualityComparer<string>.Default.Equals(_evaluatePayload, other._evaluatePayload),
            Kind.Step => true,
            Kind.Continue => true,
            _ => false
        };
    }

    /// <inheritdoc/>
    public override bool Equals(object? obj) => obj is TestCommand other && Equals(other);

    /// <inheritdoc/>
    public override int GetHashCode()
    {
        return _tag switch
        {
            Kind.SetValue => HashCode.Combine(_tag, _setValuePayload),
            Kind.SetBreakpoint => HashCode.Combine(_tag, _setBreakpointPayload),
            Kind.Evaluate => HashCode.Combine(_tag, _evaluatePayload),
            Kind.Step => HashCode.Combine(_tag),
            Kind.Continue => HashCode.Combine(_tag),
            _ => 0
        };
    }

    /// <summary>Equality operator.</summary>
    public static bool operator ==(TestCommand left, TestCommand right) => left.Equals(right);

    /// <summary>Inequality operator.</summary>
    public static bool operator !=(TestCommand left, TestCommand right) => !left.Equals(right);

    #endregion
}

