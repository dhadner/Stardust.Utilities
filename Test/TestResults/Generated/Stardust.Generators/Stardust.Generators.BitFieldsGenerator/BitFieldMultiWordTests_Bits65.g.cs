// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Globalization;
using System.Numerics;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Stardust.Utilities;

namespace Stardust.Utilities.Tests;

public partial class BitFieldMultiWordTests
{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [JsonConverter(typeof(Bits65JsonConverter))]
    public partial struct Bits65 : IComparable, IComparable<Bits65>, IEquatable<Bits65>,
                                 IFormattable, ISpanFormattable, IParsable<Bits65>, ISpanParsable<Bits65>
    {
        private ulong _w0; // bits 0-63
        private byte _w1; // bits 64-64

        /// <summary>Number of conceptual words in the backing store.</summary>
        private const int WordCount = 2;

        /// <summary>Total number of defined bits.</summary>
        private const int TotalBits = 65;

        /// <summary>Size of this struct in bytes.</summary>
        public const int SizeInBytes = 9;

        private const ulong LastWordMask = 0x0000000000000001UL;

        /// <summary>Returns a Bits65 with all bits set to zero.</summary>
        public static Bits65 Zero => default;

        /// <summary>Creates a new Bits65 from individual word values.</summary>
        /// <param name="lower">Bits 0-63 (least significant).</param>
        /// <param name="upper">Bits 64-64 (most significant).</param>
        public Bits65(ulong lower, byte upper)
        {
            _w0 = lower;
            _w1 = upper;
        }

        /// <summary>Creates a new Bits65 from a ulong value (zero-extended).</summary>
        public Bits65(ulong value) : this(value, default(byte)) { }

        /// <summary>Creates a new Bits65 from an int value. Negative values are sign-extended
        /// to all 65 bits (e.g., -1 sets all bits to 1).</summary>
        public Bits65(int value)
        {
            ulong extended = unchecked((ulong)(long)value);
            ulong fill = value < 0 ? ulong.MaxValue : 0UL;
            _w0 = extended;
            _w1 = (byte)(fill);
        }

        public partial ulong Low
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ulong)_w0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w0 = (ulong)value;
        }

        public partial bool ExtraBit
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (((ulong)_w1) & 0x1UL) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w1 = (byte)(value ? (((ulong)_w1) | 0x1UL) : (((ulong)_w1) & 0xFFFFFFFFFFFFFFFEUL));
        }

        /// <summary>Returns a Bits65 with only the ExtraBit bit set.</summary>
        public static Bits65 ExtraBitBit => new(0UL, (byte)0x1);

        /// <summary>Returns a Bits65 with the mask for the Low field (bits 0-63).</summary>
        public static Bits65 LowMask => new(0xFFFFFFFFFFFFFFFFUL, default(byte));

        /// <summary>Returns a new Bits65 with the ExtraBit flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits65 WithExtraBit(bool value) => new(_w0, (byte)(value ? (((ulong)_w1) | 0x1UL) : (((ulong)_w1) & 0xFFFFFFFFFFFFFFFEUL)));

        /// <summary>Returns a new Bits65 with the Low field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits65 WithLow(ulong value) { var copy = this; copy.Low = value; return copy; }

        /// <summary>Metadata for every field and flag declared on this struct, in declaration order.</summary>
        public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]
        {
            new("Low", 0, 64, "ulong", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
            new("ExtraBit", 64, 1, "bool", true, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
        };

        /// <summary>Bitwise complement operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator ~(Bits65 a) => new(~a._w0, (byte)(~((ulong)a._w1)));

        /// <summary>Bitwise OR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator |(Bits65 a, Bits65 b) => new(a._w0 | b._w0, (byte)(((ulong)a._w1) | ((ulong)b._w1)));

        /// <summary>Bitwise AND operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator &(Bits65 a, Bits65 b) => new(a._w0 & b._w0, (byte)(((ulong)a._w1) & ((ulong)b._w1)));

        /// <summary>Bitwise XOR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator ^(Bits65 a, Bits65 b) => new(a._w0 ^ b._w0, (byte)(((ulong)a._w1) ^ ((ulong)b._w1)));

        /// <summary>Bitwise AND operator with ulong (applied to lowest word).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator &(Bits65 a, ulong b) => new(a._w0 & b, default(byte));

        /// <summary>Unary plus operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator +(Bits65 a) => a;

        /// <summary>Unary negation operator. Returns two's complement negation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator -(Bits65 a) => ~a + new Bits65(1UL);

        /// <summary>Addition operator with carry propagation.</summary>
        public static Bits65 operator +(Bits65 a, Bits65 b)
        {
            ulong w0 = a._w0 + b._w0;
            ulong c0 = (w0 < a._w0) ? 1UL : 0UL;
            ulong w1 = ((ulong)a._w1) + ((ulong)b._w1) + c0;
            return new(w0, (byte)w1);
        }

        /// <summary>Addition operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator +(Bits65 a, ulong b) => a + new Bits65(b);

        /// <summary>Subtraction operator with borrow propagation.</summary>
        public static Bits65 operator -(Bits65 a, Bits65 b)
        {
            ulong w0 = a._w0 - b._w0;
            ulong borrow0 = (a._w0 < b._w0) ? 1UL : 0UL;
            ulong diff1 = ((ulong)a._w1) - ((ulong)b._w1);
            ulong w1 = diff1 - borrow0;
            return new(w0, (byte)w1);
        }

        /// <summary>Subtraction operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator -(Bits65 a, ulong b) => a - new Bits65(b);

        /// <summary>Multiplication operator (via BigInteger).</summary>
        public static Bits65 operator *(Bits65 a, Bits65 b) => FromBigInteger(a.ToBigInteger() * b.ToBigInteger());

        /// <summary>Multiplication operator with ulong.</summary>
        public static Bits65 operator *(Bits65 a, ulong b) => FromBigInteger(a.ToBigInteger() * b);

        /// <summary>Multiplication operator with ulong.</summary>
        public static Bits65 operator *(ulong a, Bits65 b) => FromBigInteger(a * b.ToBigInteger());

        /// <summary>Division operator (via BigInteger).</summary>
        public static Bits65 operator /(Bits65 a, Bits65 b) => FromBigInteger(a.ToBigInteger() / b.ToBigInteger());

        /// <summary>Division operator with ulong.</summary>
        public static Bits65 operator /(Bits65 a, ulong b) => FromBigInteger(a.ToBigInteger() / b);

        /// <summary>Modulus operator (via BigInteger).</summary>
        public static Bits65 operator %(Bits65 a, Bits65 b) => FromBigInteger(a.ToBigInteger() % b.ToBigInteger());

        /// <summary>Modulus operator with ulong.</summary>
        public static Bits65 operator %(Bits65 a, ulong b) => FromBigInteger(a.ToBigInteger() % b);

        /// <summary>Left shift operator.</summary>
        public static Bits65 operator <<(Bits65 a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(Bits65);
            for (int dst = WordCount - 1; dst >= 0; dst--)
            {
                int src = dst - wordShift;
                if (src < 0) continue;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, GetWord(result, dst) | (val << bitShift));
                    if (src > 0)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src - 1) >> (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Right shift operator (unsigned).</summary>
        public static Bits65 operator >>(Bits65 a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(Bits65);
            for (int dst = 0; dst < WordCount; dst++)
            {
                int src = dst + wordShift;
                if (src >= WordCount) break;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, val >> bitShift);
                    if (src + 1 < WordCount)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src + 1) << (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Unsigned right shift operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 operator >>>(Bits65 a, int amount) => a >> amount;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong GetWord(Bits65 v, int index)
        {
            return index switch
            {
                0 => v._w0,
                1 => ((ulong)v._w1),
                _ => 0UL,
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void SetWord(ref Bits65 v, int index, ulong value)
        {
            switch (index)
            {
                case 0: v._w0 = value; break;
                case 1: v._w1 = (byte)(value); break;
            }
        }

        /// <summary>Less than operator.</summary>
        public static bool operator <(Bits65 a, Bits65 b)
        {
            if (((ulong)a._w1) != ((ulong)b._w1)) return ((ulong)a._w1) < ((ulong)b._w1);
            if (a._w0 != b._w0) return a._w0 < b._w0;
            return false;
        }

        /// <summary>Greater than operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(Bits65 a, Bits65 b) => b < a;

        /// <summary>Less than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(Bits65 a, Bits65 b) => !(b < a);

        /// <summary>Greater than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(Bits65 a, Bits65 b) => !(a < b);

        /// <summary>Equality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Bits65 a, Bits65 b) => a._w0 == b._w0 && a._w1 == b._w1;

        /// <summary>Inequality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Bits65 a, Bits65 b) => !(a == b);

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        public override bool Equals(object? obj) => obj is Bits65 other && this == other;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode()
        {
            return HashCode.Combine(_w0, _w1);
        }

        /// <summary>Returns a hex string representation of the value.</summary>
        public override string ToString() => "0x" + ToBigInteger().ToString("X");

        /// <summary>Implicit conversion from ulong (zero-extended).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Bits65(ulong value) => new(value);

        /// <summary>Implicit conversion from int.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Bits65(int value) => new(value);

        /// <summary>Explicit conversion to BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator BigInteger(Bits65 value) => value.ToBigInteger();

        /// <summary>Explicit conversion from BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Bits65(BigInteger value) => FromBigInteger(value);

        /// <summary>Converts this value to a BigInteger.</summary>
        public BigInteger ToBigInteger()
        {
            BigInteger result = ((ulong)_w1);
            result = (result << 64) | _w0;
            return result;
        }

        /// <summary>Creates a Bits65 from a BigInteger (truncated to 65 bits).</summary>
        public static Bits65 FromBigInteger(BigInteger value)
        {
            if (value.Sign < 0) value = (BigInteger.One << TotalBits) + value;
            ulong w0 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w1 = (ulong)(value & ulong.MaxValue);
            return new(w0, (byte)w1);
        }

        /// <summary>Creates a new Bits65 from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public Bits65(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
            _w0 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(0));
            _w1 = bytes[8];
        }

        /// <summary>Creates a new Bits65 by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <returns>The deserialized Bits65.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

        /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public void WriteTo(Span<byte> destination)
        {
            if (destination.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(0), _w0);
            destination[8] = _w1;
        }

        /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span.</param>
        /// <param name="bytesWritten">The number of bytes written on success.</param>
        /// <returns>true if the destination span was large enough; otherwise, false.</returns>
        public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < SizeInBytes)
            {
                bytesWritten = 0;
                return false;
            }
            WriteTo(destination);
            bytesWritten = SizeInBytes;
            return true;
        }

        /// <summary>Returns the value as a new little-endian byte array.</summary>
        /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
        public byte[] ToByteArray()
        {
            var bytes = new byte[SizeInBytes];
            WriteTo(bytes);
            return bytes;
        }

        private static bool IsHexPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X');
        private static bool IsBinaryPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B');

        private static string RemoveUnderscores(ReadOnlySpan<char> s)
        {
            bool hasUnderscore = false;
            foreach (var c in s) { if (c == '_') { hasUnderscore = true; break; } }
            if (!hasUnderscore) return s.ToString();
            var sb = new System.Text.StringBuilder(s.Length);
            foreach (var c in s) { if (c != '_') sb.Append(c); }
            return sb.ToString();
        }

        /// <summary>Parses a string into a Bits65. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        public static Bits65 Parse(string s, IFormatProvider? provider)
        {
            ArgumentNullException.ThrowIfNull(s);
            var span = s.AsSpan();
            if (IsBinaryPrefix(span))
            {
                BigInteger val = 0;
                foreach (var c in RemoveUnderscores(span.Slice(2)))
                    val = (val << 1) | (c == '1' ? 1 : 0);
                return FromBigInteger(val);
            }
            if (IsHexPrefix(span))
                return FromBigInteger(BigInteger.Parse("0" + RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider));
            return FromBigInteger(BigInteger.Parse(RemoveUnderscores(span), NumberStyles.Integer, provider));
        }

        /// <summary>Tries to parse a string into a Bits65.</summary>
        public static bool TryParse(string? s, IFormatProvider? provider, out Bits65 result)
        {
            if (s is null) { result = default; return false; }
            try { result = Parse(s, provider); return true; }
            catch { result = default; return false; }
        }

        /// <summary>Parses a span of characters into a Bits65.</summary>
        public static Bits65 Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Parse(s.ToString(), provider);

        /// <summary>Tries to parse a span of characters into a Bits65.</summary>
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Bits65 result) => TryParse(s.ToString(), provider, out result);

        /// <summary>Parses a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits65 Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

        /// <summary>Tries to parse a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParse(string? s, out Bits65 result) => TryParse(s, CultureInfo.InvariantCulture, out result);

        /// <summary>Formats the value using the specified format and format provider.</summary>
        public string ToString(string? format, IFormatProvider? formatProvider) => ToBigInteger().ToString(format, formatProvider);

        /// <summary>Tries to format the value into the provided span of characters.</summary>
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            var str = ToString(format.ToString(), provider);
            if (str.Length <= destination.Length)
            {
                str.AsSpan().CopyTo(destination);
                charsWritten = str.Length;
                return true;
            }
            charsWritten = 0;
            return false;
        }

        /// <summary>Compares this instance to a specified object.</summary>
        public int CompareTo(object? obj)
        {
            if (obj is null) return 1;
            if (obj is Bits65 other) return CompareTo(other);
            throw new ArgumentException("Object must be of type Bits65", nameof(obj));
        }

        /// <summary>Compares this instance to another Bits65.</summary>
        public int CompareTo(Bits65 other)
        {
            if (((ulong)_w1) != ((ulong)other._w1)) return ((ulong)_w1).CompareTo(((ulong)other._w1));
            if (_w0 != other._w0) return _w0.CompareTo(other._w0);
            return 0;
        }

        /// <summary>Indicates whether this instance is equal to another Bits65.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Bits65 other) => this == other;

        /// <summary>JSON converter that serializes Bits65 as a hex string.</summary>
        private sealed class Bits65JsonConverter : JsonConverter<Bits65>
        {
            /// <summary>Reads a Bits65 from a JSON string.</summary>
            public override Bits65 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var s = reader.GetString();
                return s is null ? default : Bits65.Parse(s);
            }

            /// <summary>Writes a Bits65 to JSON as a hex string.</summary>
            public override void Write(Utf8JsonWriter writer, Bits65 value, JsonSerializerOptions options)
            {
                writer.WriteStringValue(value.ToString());
            }
        }

    }
}
