// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Globalization;
using System.Numerics;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Stardust.Utilities;

namespace Stardust.Utilities.Tests;

public partial class BitFieldMultiWordTests
{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [JsonConverter(typeof(Bits200JsonConverter))]
    public partial struct Bits200 : IComparable, IComparable<Bits200>, IEquatable<Bits200>,
                                 IFormattable, ISpanFormattable, IParsable<Bits200>, ISpanParsable<Bits200>
    {
        private ulong _w0; // bits 0-63
        private ulong _w1; // bits 64-127
        private ulong _w2; // bits 128-191
        private byte _w3; // bits 192-199

        /// <summary>Number of conceptual words in the backing store.</summary>
        private const int WordCount = 4;

        /// <summary>Total number of defined bits.</summary>
        private const int TotalBits = 200;

        /// <summary>Size of this struct in bytes.</summary>
        public const int SizeInBytes = 25;

        private const ulong LastWordMask = 0x00000000000000FFUL;

        /// <summary>Returns a Bits200 with all bits set to zero.</summary>
        public static Bits200 Zero => default;

        /// <summary>Creates a new Bits200 from individual word values.</summary>
        /// <param name="lower">Bits 0-63 (least significant).</param>
        /// <param name="midLower">Bits 64-127.</param>
        /// <param name="midUpper">Bits 128-191.</param>
        /// <param name="upper">Bits 192-199 (most significant).</param>
        public Bits200(ulong lower, ulong midLower, ulong midUpper, byte upper)
        {
            _w0 = lower;
            _w1 = midLower;
            _w2 = midUpper;
            _w3 = upper;
        }

        /// <summary>Creates a new Bits200 from a ulong value (zero-extended).</summary>
        public Bits200(ulong value) : this(value, 0UL, 0UL, default(byte)) { }

        /// <summary>Creates a new Bits200 from an int value. Negative values are sign-extended
        /// to all 200 bits (e.g., -1 sets all bits to 1).</summary>
        public Bits200(int value)
        {
            ulong extended = unchecked((ulong)(long)value);
            ulong fill = value < 0 ? ulong.MaxValue : 0UL;
            _w0 = extended;
            _w1 = fill;
            _w2 = fill;
            _w3 = (byte)(fill);
        }

        public partial ulong Word0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ulong)_w0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w0 = (ulong)value;
        }

        public partial ulong Word1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ulong)_w1;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w1 = (ulong)value;
        }

        public partial ulong Word2
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ulong)_w2;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w2 = (ulong)value;
        }

        public partial byte Tag
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (byte)((((ulong)_w3) >> 1) & 0x7FUL);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w3 = (byte)((((ulong)_w3) & 0xFFFFFFFFFFFFFF01UL) | (((ulong)value << 1) & 0x00000000000000FEUL));
        }

        public partial bool Valid
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (((ulong)_w3) & 0x1UL) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w3 = (byte)(value ? (((ulong)_w3) | 0x1UL) : (((ulong)_w3) & 0xFFFFFFFFFFFFFFFEUL));
        }

        /// <summary>Returns a Bits200 with only the Valid bit set.</summary>
        public static Bits200 ValidBit => new(0UL, 0UL, 0UL, (byte)0x1);

        /// <summary>Returns a Bits200 with the mask for the Word0 field (bits 0-63).</summary>
        public static Bits200 Word0Mask => new(0xFFFFFFFFFFFFFFFFUL, 0UL, 0UL, default(byte));

        /// <summary>Returns a Bits200 with the mask for the Word1 field (bits 64-127).</summary>
        public static Bits200 Word1Mask => new(0UL, 0xFFFFFFFFFFFFFFFFUL, 0UL, default(byte));

        /// <summary>Returns a Bits200 with the mask for the Word2 field (bits 128-191).</summary>
        public static Bits200 Word2Mask => new(0UL, 0UL, 0xFFFFFFFFFFFFFFFFUL, default(byte));

        /// <summary>Returns a Bits200 with the mask for the Tag field (bits 193-199).</summary>
        public static Bits200 TagMask => new(0UL, 0UL, 0UL, (byte)0xFE);

        /// <summary>Returns a new Bits200 with the Valid flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits200 WithValid(bool value) => new(_w0, _w1, _w2, (byte)(value ? (((ulong)_w3) | 0x1UL) : (((ulong)_w3) & 0xFFFFFFFFFFFFFFFEUL)));

        /// <summary>Returns a new Bits200 with the Word0 field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits200 WithWord0(ulong value) { var copy = this; copy.Word0 = value; return copy; }

        /// <summary>Returns a new Bits200 with the Word1 field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits200 WithWord1(ulong value) { var copy = this; copy.Word1 = value; return copy; }

        /// <summary>Returns a new Bits200 with the Word2 field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits200 WithWord2(ulong value) { var copy = this; copy.Word2 = value; return copy; }

        /// <summary>Returns a new Bits200 with the Tag field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits200 WithTag(byte value) { var copy = this; copy.Tag = value; return copy; }

        /// <summary>Metadata for every field and flag declared on this struct, in declaration order.</summary>
        public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]
        {
            new("Word0", 0, 64, "ulong", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
            new("Word1", 64, 64, "ulong", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
            new("Word2", 128, 64, "ulong", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
            new("Tag", 193, 7, "byte", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
            new("Valid", 192, 1, "bool", true, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
        };

        /// <summary>Bitwise complement operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator ~(Bits200 a) => new(~a._w0, ~a._w1, ~a._w2, (byte)(~((ulong)a._w3)));

        /// <summary>Bitwise OR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator |(Bits200 a, Bits200 b) => new(a._w0 | b._w0, a._w1 | b._w1, a._w2 | b._w2, (byte)(((ulong)a._w3) | ((ulong)b._w3)));

        /// <summary>Bitwise AND operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator &(Bits200 a, Bits200 b) => new(a._w0 & b._w0, a._w1 & b._w1, a._w2 & b._w2, (byte)(((ulong)a._w3) & ((ulong)b._w3)));

        /// <summary>Bitwise XOR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator ^(Bits200 a, Bits200 b) => new(a._w0 ^ b._w0, a._w1 ^ b._w1, a._w2 ^ b._w2, (byte)(((ulong)a._w3) ^ ((ulong)b._w3)));

        /// <summary>Bitwise AND operator with ulong (applied to lowest word).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator &(Bits200 a, ulong b) => new(a._w0 & b, 0UL, 0UL, default(byte));

        /// <summary>Unary plus operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator +(Bits200 a) => a;

        /// <summary>Unary negation operator. Returns two's complement negation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator -(Bits200 a) => ~a + new Bits200(1UL);

        /// <summary>Addition operator with carry propagation.</summary>
        public static Bits200 operator +(Bits200 a, Bits200 b)
        {
            ulong w0 = a._w0 + b._w0;
            ulong c0 = (w0 < a._w0) ? 1UL : 0UL;
            ulong w1 = a._w1 + b._w1 + c0;
            ulong c1 = (w1 < a._w1 || (c0 != 0 && w1 == a._w1)) ? 1UL : 0UL;
            ulong w2 = a._w2 + b._w2 + c1;
            ulong c2 = (w2 < a._w2 || (c1 != 0 && w2 == a._w2)) ? 1UL : 0UL;
            ulong w3 = ((ulong)a._w3) + ((ulong)b._w3) + c2;
            return new(w0, w1, w2, (byte)w3);
        }

        /// <summary>Addition operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator +(Bits200 a, ulong b) => a + new Bits200(b);

        /// <summary>Subtraction operator with borrow propagation.</summary>
        public static Bits200 operator -(Bits200 a, Bits200 b)
        {
            ulong w0 = a._w0 - b._w0;
            ulong borrow0 = (a._w0 < b._w0) ? 1UL : 0UL;
            ulong diff1 = a._w1 - b._w1;
            ulong w1 = diff1 - borrow0;
            ulong borrow1 = (a._w1 < b._w1 || (borrow0 != 0 && diff1 == 0)) ? 1UL : 0UL;
            ulong diff2 = a._w2 - b._w2;
            ulong w2 = diff2 - borrow1;
            ulong borrow2 = (a._w2 < b._w2 || (borrow1 != 0 && diff2 == 0)) ? 1UL : 0UL;
            ulong diff3 = ((ulong)a._w3) - ((ulong)b._w3);
            ulong w3 = diff3 - borrow2;
            return new(w0, w1, w2, (byte)w3);
        }

        /// <summary>Subtraction operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator -(Bits200 a, ulong b) => a - new Bits200(b);

        /// <summary>Multiplication operator (via BigInteger).</summary>
        public static Bits200 operator *(Bits200 a, Bits200 b) => FromBigInteger(a.ToBigInteger() * b.ToBigInteger());

        /// <summary>Multiplication operator with ulong.</summary>
        public static Bits200 operator *(Bits200 a, ulong b) => FromBigInteger(a.ToBigInteger() * b);

        /// <summary>Multiplication operator with ulong.</summary>
        public static Bits200 operator *(ulong a, Bits200 b) => FromBigInteger(a * b.ToBigInteger());

        /// <summary>Division operator (via BigInteger).</summary>
        public static Bits200 operator /(Bits200 a, Bits200 b) => FromBigInteger(a.ToBigInteger() / b.ToBigInteger());

        /// <summary>Division operator with ulong.</summary>
        public static Bits200 operator /(Bits200 a, ulong b) => FromBigInteger(a.ToBigInteger() / b);

        /// <summary>Modulus operator (via BigInteger).</summary>
        public static Bits200 operator %(Bits200 a, Bits200 b) => FromBigInteger(a.ToBigInteger() % b.ToBigInteger());

        /// <summary>Modulus operator with ulong.</summary>
        public static Bits200 operator %(Bits200 a, ulong b) => FromBigInteger(a.ToBigInteger() % b);

        /// <summary>Left shift operator.</summary>
        public static Bits200 operator <<(Bits200 a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(Bits200);
            for (int dst = WordCount - 1; dst >= 0; dst--)
            {
                int src = dst - wordShift;
                if (src < 0) continue;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, GetWord(result, dst) | (val << bitShift));
                    if (src > 0)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src - 1) >> (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Right shift operator (unsigned).</summary>
        public static Bits200 operator >>(Bits200 a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(Bits200);
            for (int dst = 0; dst < WordCount; dst++)
            {
                int src = dst + wordShift;
                if (src >= WordCount) break;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, val >> bitShift);
                    if (src + 1 < WordCount)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src + 1) << (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Unsigned right shift operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 operator >>>(Bits200 a, int amount) => a >> amount;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong GetWord(Bits200 v, int index)
        {
            return index switch
            {
                0 => v._w0,
                1 => v._w1,
                2 => v._w2,
                3 => ((ulong)v._w3),
                _ => 0UL,
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void SetWord(ref Bits200 v, int index, ulong value)
        {
            switch (index)
            {
                case 0: v._w0 = value; break;
                case 1: v._w1 = value; break;
                case 2: v._w2 = value; break;
                case 3: v._w3 = (byte)(value); break;
            }
        }

        /// <summary>Less than operator.</summary>
        public static bool operator <(Bits200 a, Bits200 b)
        {
            if (((ulong)a._w3) != ((ulong)b._w3)) return ((ulong)a._w3) < ((ulong)b._w3);
            if (a._w2 != b._w2) return a._w2 < b._w2;
            if (a._w1 != b._w1) return a._w1 < b._w1;
            if (a._w0 != b._w0) return a._w0 < b._w0;
            return false;
        }

        /// <summary>Greater than operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(Bits200 a, Bits200 b) => b < a;

        /// <summary>Less than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(Bits200 a, Bits200 b) => !(b < a);

        /// <summary>Greater than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(Bits200 a, Bits200 b) => !(a < b);

        /// <summary>Equality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Bits200 a, Bits200 b) => a._w0 == b._w0 && a._w1 == b._w1 && a._w2 == b._w2 && a._w3 == b._w3;

        /// <summary>Inequality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Bits200 a, Bits200 b) => !(a == b);

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        public override bool Equals(object? obj) => obj is Bits200 other && this == other;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode()
        {
            return HashCode.Combine(_w0, _w1, _w2, _w3);
        }

        /// <summary>Returns a hex string representation of the value.</summary>
        public override string ToString() => "0x" + ToBigInteger().ToString("X");

        /// <summary>Implicit conversion from ulong (zero-extended).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Bits200(ulong value) => new(value);

        /// <summary>Implicit conversion from int.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Bits200(int value) => new(value);

        /// <summary>Explicit conversion to BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator BigInteger(Bits200 value) => value.ToBigInteger();

        /// <summary>Explicit conversion from BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Bits200(BigInteger value) => FromBigInteger(value);

        /// <summary>Converts this value to a BigInteger.</summary>
        public BigInteger ToBigInteger()
        {
            BigInteger result = ((ulong)_w3);
            result = (result << 64) | _w2;
            result = (result << 64) | _w1;
            result = (result << 64) | _w0;
            return result;
        }

        /// <summary>Creates a Bits200 from a BigInteger (truncated to 200 bits).</summary>
        public static Bits200 FromBigInteger(BigInteger value)
        {
            if (value.Sign < 0) value = (BigInteger.One << TotalBits) + value;
            ulong w0 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w1 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w2 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w3 = (ulong)(value & ulong.MaxValue);
            return new(w0, w1, w2, (byte)w3);
        }

        /// <summary>Creates a new Bits200 from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public Bits200(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
            _w0 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(0));
            _w1 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(8));
            _w2 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(16));
            _w3 = bytes[24];
        }

        /// <summary>Creates a new Bits200 by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <returns>The deserialized Bits200.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

        /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public void WriteTo(Span<byte> destination)
        {
            if (destination.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(0), _w0);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(8), _w1);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(16), _w2);
            destination[24] = _w3;
        }

        /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span.</param>
        /// <param name="bytesWritten">The number of bytes written on success.</param>
        /// <returns>true if the destination span was large enough; otherwise, false.</returns>
        public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < SizeInBytes)
            {
                bytesWritten = 0;
                return false;
            }
            WriteTo(destination);
            bytesWritten = SizeInBytes;
            return true;
        }

        /// <summary>Returns the value as a new little-endian byte array.</summary>
        /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
        public byte[] ToByteArray()
        {
            var bytes = new byte[SizeInBytes];
            WriteTo(bytes);
            return bytes;
        }

        private static bool IsHexPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X');
        private static bool IsBinaryPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B');

        private static string RemoveUnderscores(ReadOnlySpan<char> s)
        {
            bool hasUnderscore = false;
            foreach (var c in s) { if (c == '_') { hasUnderscore = true; break; } }
            if (!hasUnderscore) return s.ToString();
            var sb = new System.Text.StringBuilder(s.Length);
            foreach (var c in s) { if (c != '_') sb.Append(c); }
            return sb.ToString();
        }

        /// <summary>Parses a string into a Bits200. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        public static Bits200 Parse(string s, IFormatProvider? provider)
        {
            ArgumentNullException.ThrowIfNull(s);
            var span = s.AsSpan();
            if (IsBinaryPrefix(span))
            {
                BigInteger val = 0;
                foreach (var c in RemoveUnderscores(span.Slice(2)))
                    val = (val << 1) | (c == '1' ? 1 : 0);
                return FromBigInteger(val);
            }
            if (IsHexPrefix(span))
                return FromBigInteger(BigInteger.Parse("0" + RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider));
            return FromBigInteger(BigInteger.Parse(RemoveUnderscores(span), NumberStyles.Integer, provider));
        }

        /// <summary>Tries to parse a string into a Bits200.</summary>
        public static bool TryParse(string? s, IFormatProvider? provider, out Bits200 result)
        {
            if (s is null) { result = default; return false; }
            try { result = Parse(s, provider); return true; }
            catch { result = default; return false; }
        }

        /// <summary>Parses a span of characters into a Bits200.</summary>
        public static Bits200 Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Parse(s.ToString(), provider);

        /// <summary>Tries to parse a span of characters into a Bits200.</summary>
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Bits200 result) => TryParse(s.ToString(), provider, out result);

        /// <summary>Parses a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits200 Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

        /// <summary>Tries to parse a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParse(string? s, out Bits200 result) => TryParse(s, CultureInfo.InvariantCulture, out result);

        /// <summary>Formats the value using the specified format and format provider.</summary>
        public string ToString(string? format, IFormatProvider? formatProvider) => ToBigInteger().ToString(format, formatProvider);

        /// <summary>Tries to format the value into the provided span of characters.</summary>
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            var str = ToString(format.ToString(), provider);
            if (str.Length <= destination.Length)
            {
                str.AsSpan().CopyTo(destination);
                charsWritten = str.Length;
                return true;
            }
            charsWritten = 0;
            return false;
        }

        /// <summary>Compares this instance to a specified object.</summary>
        public int CompareTo(object? obj)
        {
            if (obj is null) return 1;
            if (obj is Bits200 other) return CompareTo(other);
            throw new ArgumentException("Object must be of type Bits200", nameof(obj));
        }

        /// <summary>Compares this instance to another Bits200.</summary>
        public int CompareTo(Bits200 other)
        {
            if (((ulong)_w3) != ((ulong)other._w3)) return ((ulong)_w3).CompareTo(((ulong)other._w3));
            if (_w2 != other._w2) return _w2.CompareTo(other._w2);
            if (_w1 != other._w1) return _w1.CompareTo(other._w1);
            if (_w0 != other._w0) return _w0.CompareTo(other._w0);
            return 0;
        }

        /// <summary>Indicates whether this instance is equal to another Bits200.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Bits200 other) => this == other;

        /// <summary>JSON converter that serializes Bits200 as a hex string.</summary>
        private sealed class Bits200JsonConverter : JsonConverter<Bits200>
        {
            /// <summary>Reads a Bits200 from a JSON string.</summary>
            public override Bits200 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var s = reader.GetString();
                return s is null ? default : Bits200.Parse(s);
            }

            /// <summary>Writes a Bits200 to JSON as a hex string.</summary>
            public override void Write(Utf8JsonWriter writer, Bits200 value, JsonSerializerOptions options)
            {
                writer.WriteStringValue(value.ToString());
            }
        }

    }
}
