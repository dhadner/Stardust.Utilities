// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Buffers.Binary;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Stardust.Utilities.Tests;

public partial class BitFieldProtocolTests
{
    [JsonConverter(typeof(TcpFlagsJsonConverter))]
    public partial struct TcpFlags : IComparable, IComparable<TcpFlags>, IEquatable<TcpFlags>,
                                 IFormattable, ISpanFormattable, IParsable<TcpFlags>, ISpanParsable<TcpFlags>
    {
        private ushort Value;

        /// <summary>Size of this struct in bytes.</summary>
        public const int SizeInBytes = 2;

        /// <summary>Returns a TcpFlags with all bits set to zero.</summary>
        public static TcpFlags Zero => default;

        /// <summary>Creates a new TcpFlags with the specified raw bits value.</summary>
        public TcpFlags(ushort value) { Value = (ushort)(value & 0x01FF); }

        public partial bool FIN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0001) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0001) : (ushort)(Value & 0xFFFE);
        }

        public partial bool SYN
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0002) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0002) : (ushort)(Value & 0xFFFD);
        }

        public partial bool RST
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0004) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0004) : (ushort)(Value & 0xFFFB);
        }

        public partial bool PSH
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0008) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0008) : (ushort)(Value & 0xFFF7);
        }

        public partial bool ACK
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0010) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0010) : (ushort)(Value & 0xFFEF);
        }

        public partial bool URG
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0020) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0020) : (ushort)(Value & 0xFFDF);
        }

        public partial bool ECE
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0040) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0040) : (ushort)(Value & 0xFFBF);
        }

        public partial bool CWR
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0080) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0080) : (ushort)(Value & 0xFF7F);
        }

        public partial bool NS
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x0100) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ushort)(Value | 0x0100) : (ushort)(Value & 0xFEFF);
        }

        /// <summary>Returns a TcpFlags with only the FIN bit set.</summary>
        public static TcpFlags FINBit => new((ushort)0x0001);

        /// <summary>Returns a TcpFlags with only the SYN bit set.</summary>
        public static TcpFlags SYNBit => new((ushort)0x0002);

        /// <summary>Returns a TcpFlags with only the RST bit set.</summary>
        public static TcpFlags RSTBit => new((ushort)0x0004);

        /// <summary>Returns a TcpFlags with only the PSH bit set.</summary>
        public static TcpFlags PSHBit => new((ushort)0x0008);

        /// <summary>Returns a TcpFlags with only the ACK bit set.</summary>
        public static TcpFlags ACKBit => new((ushort)0x0010);

        /// <summary>Returns a TcpFlags with only the URG bit set.</summary>
        public static TcpFlags URGBit => new((ushort)0x0020);

        /// <summary>Returns a TcpFlags with only the ECE bit set.</summary>
        public static TcpFlags ECEBit => new((ushort)0x0040);

        /// <summary>Returns a TcpFlags with only the CWR bit set.</summary>
        public static TcpFlags CWRBit => new((ushort)0x0080);

        /// <summary>Returns a TcpFlags with only the NS bit set.</summary>
        public static TcpFlags NSBit => new((ushort)0x0100);

        /// <summary>Returns a new TcpFlags with the FIN flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithFIN(bool value) => new(value ? (ushort)(Value | 0x0001) : (ushort)(Value & 0xFFFE));

        /// <summary>Returns a new TcpFlags with the SYN flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithSYN(bool value) => new(value ? (ushort)(Value | 0x0002) : (ushort)(Value & 0xFFFD));

        /// <summary>Returns a new TcpFlags with the RST flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithRST(bool value) => new(value ? (ushort)(Value | 0x0004) : (ushort)(Value & 0xFFFB));

        /// <summary>Returns a new TcpFlags with the PSH flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithPSH(bool value) => new(value ? (ushort)(Value | 0x0008) : (ushort)(Value & 0xFFF7));

        /// <summary>Returns a new TcpFlags with the ACK flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithACK(bool value) => new(value ? (ushort)(Value | 0x0010) : (ushort)(Value & 0xFFEF));

        /// <summary>Returns a new TcpFlags with the URG flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithURG(bool value) => new(value ? (ushort)(Value | 0x0020) : (ushort)(Value & 0xFFDF));

        /// <summary>Returns a new TcpFlags with the ECE flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithECE(bool value) => new(value ? (ushort)(Value | 0x0040) : (ushort)(Value & 0xFFBF));

        /// <summary>Returns a new TcpFlags with the CWR flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithCWR(bool value) => new(value ? (ushort)(Value | 0x0080) : (ushort)(Value & 0xFF7F));

        /// <summary>Returns a new TcpFlags with the NS flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public TcpFlags WithNS(bool value) => new(value ? (ushort)(Value | 0x0100) : (ushort)(Value & 0xFEFF));

        /// <summary>Bitwise complement operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator ~(TcpFlags a) => new((ushort)~a.Value);

        /// <summary>Bitwise OR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator |(TcpFlags a, TcpFlags b) => new((ushort)(a.Value | b.Value));

        /// <summary>Bitwise AND operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator &(TcpFlags a, TcpFlags b) => new((ushort)(a.Value & b.Value));

        /// <summary>Bitwise XOR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator ^(TcpFlags a, TcpFlags b) => new((ushort)(a.Value ^ b.Value));

        /// <summary>Unary plus operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator +(TcpFlags a) => a;

        /// <summary>Unary negation operator. Returns two's complement negation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator -(TcpFlags a) => new(unchecked((ushort)(0 - a.Value)));

        /// <summary>Addition operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator +(TcpFlags a, TcpFlags b) => new(unchecked((ushort)(a.Value + b.Value)));

        /// <summary>Addition operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator +(TcpFlags a, ushort b) => new(unchecked((ushort)(a.Value + b)));

        /// <summary>Addition operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator +(ushort a, TcpFlags b) => new(unchecked((ushort)(a + b.Value)));

        /// <summary>Subtraction operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator -(TcpFlags a, TcpFlags b) => new(unchecked((ushort)(a.Value - b.Value)));

        /// <summary>Subtraction operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator -(TcpFlags a, ushort b) => new(unchecked((ushort)(a.Value - b)));

        /// <summary>Subtraction operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator -(ushort a, TcpFlags b) => new(unchecked((ushort)(a - b.Value)));

        /// <summary>Multiplication operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator *(TcpFlags a, TcpFlags b) => new(unchecked((ushort)(a.Value * b.Value)));

        /// <summary>Multiplication operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator *(TcpFlags a, ushort b) => new(unchecked((ushort)(a.Value * b)));

        /// <summary>Multiplication operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator *(ushort a, TcpFlags b) => new(unchecked((ushort)(a * b.Value)));

        /// <summary>Division operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator /(TcpFlags a, TcpFlags b) => new((ushort)(a.Value / b.Value));

        /// <summary>Division operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator /(TcpFlags a, ushort b) => new((ushort)(a.Value / b));

        /// <summary>Division operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator /(ushort a, TcpFlags b) => new((ushort)(a / b.Value));

        /// <summary>Modulus operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator %(TcpFlags a, TcpFlags b) => new((ushort)(a.Value % b.Value));

        /// <summary>Modulus operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator %(TcpFlags a, ushort b) => new((ushort)(a.Value % b));

        /// <summary>Modulus operator with storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags operator %(ushort a, TcpFlags b) => new((ushort)(a % b.Value));

        /// <summary>Left shift operator. Returns int for intuitive bitwise operations with literals.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int operator <<(TcpFlags a, int b) => a.Value << b;

        /// <summary>Right shift operator. Returns int for intuitive bitwise operations with literals.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int operator >>(TcpFlags a, int b) => a.Value >> b;

        /// <summary>Unsigned right shift operator. Returns int for intuitive bitwise operations with literals.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int operator >>>(TcpFlags a, int b) => a.Value >>> b;

        /// <summary>Less than operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(TcpFlags a, TcpFlags b) => a.Value < b.Value;

        /// <summary>Greater than operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(TcpFlags a, TcpFlags b) => a.Value > b.Value;

        /// <summary>Less than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(TcpFlags a, TcpFlags b) => a.Value <= b.Value;

        /// <summary>Greater than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(TcpFlags a, TcpFlags b) => a.Value >= b.Value;

        /// <summary>Equality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(TcpFlags a, TcpFlags b) => a.Value == b.Value;

        /// <summary>Inequality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(TcpFlags a, TcpFlags b) => a.Value != b.Value;

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        public override bool Equals(object? obj) => obj is TcpFlags other && Value == other.Value;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode() => Value.GetHashCode();

        /// <summary>Returns a string representation of the value.</summary>
        public override string ToString() => $"0x{Value:X}";

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ushort(TcpFlags value) => value.Value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator TcpFlags(ushort value) => new(value);

        /// <summary>Implicit conversion from int. Truncates to storage type.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator TcpFlags(int value) => new(unchecked((ushort)value));

        /// <summary>Creates a new TcpFlags from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public TcpFlags(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
            Value = BinaryPrimitives.ReadUInt16LittleEndian(bytes);
        }

        /// <summary>Creates a new TcpFlags by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <returns>The deserialized TcpFlags.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

        /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public void WriteTo(Span<byte> destination)
        {
            if (destination.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
            BinaryPrimitives.WriteUInt16LittleEndian(destination, Value);
        }

        /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span.</param>
        /// <param name="bytesWritten">The number of bytes written on success.</param>
        /// <returns>true if the destination span was large enough; otherwise, false.</returns>
        public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < SizeInBytes)
            {
                bytesWritten = 0;
                return false;
            }
            WriteTo(destination);
            bytesWritten = SizeInBytes;
            return true;
        }

        /// <summary>Returns the value as a new little-endian byte array.</summary>
        /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
        public byte[] ToByteArray()
        {
            var bytes = new byte[SizeInBytes];
            WriteTo(bytes);
            return bytes;
        }

        private static bool IsHexPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X');
        private static bool IsBinaryPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B');

        private static string RemoveUnderscores(ReadOnlySpan<char> s)
        {
            // Fast path: no underscores
            bool hasUnderscore = false;
            foreach (var c in s) { if (c == '_') { hasUnderscore = true; break; } }
            if (!hasUnderscore) return s.ToString();

            // Remove underscores
            var sb = new System.Text.StringBuilder(s.Length);
            foreach (var c in s) { if (c != '_') sb.Append(c); }
            return sb.ToString();
        }

        private static ushort ParseBinary(ReadOnlySpan<char> s)
        {
            var clean = RemoveUnderscores(s);
            return Convert.ToUInt16(clean, 2);
        }

        private static bool TryParseBinary(ReadOnlySpan<char> s, out ushort result)
        {
            try
            {
                result = ParseBinary(s);
                return true;
            }
            catch
            {
                result = default;
                return false;
            }
        }

        /// <summary>Parses a string into a TcpFlags. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="provider">An object that provides culture-specific formatting information.</param>
        /// <returns>The parsed TcpFlags value.</returns>
        /// <exception cref="ArgumentNullException">s is null.</exception>
        public static TcpFlags Parse(string s, IFormatProvider? provider)
        {
            ArgumentNullException.ThrowIfNull(s);
            var span = s.AsSpan();
            if (IsBinaryPrefix(span))
                return new(ParseBinary(span.Slice(2)));
            if (IsHexPrefix(span))
                return new(ushort.Parse(RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider));
            return new(ushort.Parse(RemoveUnderscores(span), NumberStyles.Integer, provider));
        }

        /// <summary>Tries to parse a string into a TcpFlags. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="provider">An object that provides culture-specific formatting information.</param>
        /// <param name="result">When this method returns, contains the parsed value if successful.</param>
        /// <returns>true if parsing succeeded; otherwise, false.</returns>
        public static bool TryParse(string? s, IFormatProvider? provider, out TcpFlags result)
        {
            if (s is null) { result = default; return false; }
            var span = s.AsSpan();
            if (IsBinaryPrefix(span))
            {
                if (TryParseBinary(span.Slice(2), out var binValue))
                {
                    result = new(binValue);
                    return true;
                }
                result = default;
                return false;
            }
            if (IsHexPrefix(span))
            {
                if (ushort.TryParse(RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider, out var hexValue))
                {
                    result = new(hexValue);
                    return true;
                }
                result = default;
                return false;
            }
            if (ushort.TryParse(RemoveUnderscores(span), NumberStyles.Integer, provider, out var value))
            {
                result = new(value);
                return true;
            }
            result = default;
            return false;
        }

        /// <summary>Parses a span of characters into a TcpFlags. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        /// <param name="s">The span of characters to parse.</param>
        /// <param name="provider">An object that provides culture-specific formatting information.</param>
        /// <returns>The parsed TcpFlags value.</returns>
        public static TcpFlags Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
        {
            if (IsBinaryPrefix(s))
                return new(ParseBinary(s.Slice(2)));
            if (IsHexPrefix(s))
                return new(ushort.Parse(RemoveUnderscores(s.Slice(2)), NumberStyles.HexNumber, provider));
            return new(ushort.Parse(RemoveUnderscores(s), NumberStyles.Integer, provider));
        }

        /// <summary>Tries to parse a span of characters into a TcpFlags. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        /// <param name="s">The span of characters to parse.</param>
        /// <param name="provider">An object that provides culture-specific formatting information.</param>
        /// <param name="result">When this method returns, contains the parsed value if successful.</param>
        /// <returns>true if parsing succeeded; otherwise, false.</returns>
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out TcpFlags result)
        {
            if (IsBinaryPrefix(s))
            {
                if (TryParseBinary(s.Slice(2), out var binValue))
                {
                    result = new(binValue);
                    return true;
                }
                result = default;
                return false;
            }
            if (IsHexPrefix(s))
            {
                if (ushort.TryParse(RemoveUnderscores(s.Slice(2)), NumberStyles.HexNumber, provider, out var hexValue))
                {
                    result = new(hexValue);
                    return true;
                }
                result = default;
                return false;
            }
            if (ushort.TryParse(RemoveUnderscores(s), NumberStyles.Integer, provider, out var value))
            {
                result = new(value);
                return true;
            }
            result = default;
            return false;
        }

        /// <summary>Parses a string into a TcpFlags using invariant culture. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        /// <param name="s">The string to parse.</param>
        /// <returns>The parsed TcpFlags value.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static TcpFlags Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

        /// <summary>Tries to parse a string into a TcpFlags using invariant culture. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        /// <param name="s">The string to parse.</param>
        /// <param name="result">When this method returns, contains the parsed value if successful.</param>
        /// <returns>true if parsing succeeded; otherwise, false.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParse(string? s, out TcpFlags result) => TryParse(s, CultureInfo.InvariantCulture, out result);

        /// <summary>Formats the value using the specified format and format provider.</summary>
        /// <param name="format">The format to use, or null for the default format.</param>
        /// <param name="formatProvider">The provider to use for culture-specific formatting.</param>
        /// <returns>The formatted string representation of the value.</returns>
        public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);

        /// <summary>Tries to format the value into the provided span of characters.</summary>
        /// <param name="destination">The span to write to.</param>
        /// <param name="charsWritten">The number of characters written.</param>
        /// <param name="format">The format to use.</param>
        /// <param name="provider">The provider to use for culture-specific formatting.</param>
        /// <returns>true if the formatting was successful; otherwise, false.</returns>
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
            => Value.TryFormat(destination, out charsWritten, format, provider);

        /// <summary>Compares this instance to a specified object and returns an integer indicating their relative order.</summary>
        /// <param name="obj">An object to compare, or null.</param>
        /// <returns>A value indicating the relative order of the objects being compared.</returns>
        /// <exception cref="ArgumentException">obj is not a TcpFlags.</exception>
        public int CompareTo(object? obj)
        {
            if (obj is null) return 1;
            if (obj is TcpFlags other) return CompareTo(other);
            throw new ArgumentException("Object must be of type TcpFlags", nameof(obj));
        }

        /// <summary>Compares this instance to another TcpFlags and returns an integer indicating their relative order.</summary>
        /// <param name="other">A TcpFlags to compare.</param>
        /// <returns>A value indicating the relative order of the instances being compared.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CompareTo(TcpFlags other) => Value.CompareTo(other.Value);

        /// <summary>Indicates whether this instance is equal to another TcpFlags.</summary>
        /// <param name="other">A TcpFlags to compare with this instance.</param>
        /// <returns>true if the two instances are equal; otherwise, false.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(TcpFlags other) => Value == other.Value;

        /// <summary>JSON converter that serializes TcpFlags as a string.</summary>
        private sealed class TcpFlagsJsonConverter : JsonConverter<TcpFlags>
        {
            /// <summary>Reads a TcpFlags from a JSON string.</summary>
            public override TcpFlags Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var s = reader.GetString();
                return s is null ? default : TcpFlags.Parse(s);
            }

            /// <summary>Writes a TcpFlags to JSON as a string.</summary>
            public override void Write(Utf8JsonWriter writer, TcpFlags value, JsonSerializerOptions options)
            {
                writer.WriteStringValue(value.ToString());
            }
        }

    }
}
