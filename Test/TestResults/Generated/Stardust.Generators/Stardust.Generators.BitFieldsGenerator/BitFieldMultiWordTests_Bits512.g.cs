// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Globalization;
using System.Numerics;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Stardust.Utilities;

namespace Stardust.Utilities.Tests;

public partial class BitFieldMultiWordTests
{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [JsonConverter(typeof(Bits512JsonConverter))]
    public partial struct Bits512 : IComparable, IComparable<Bits512>, IEquatable<Bits512>,
                                 IFormattable, ISpanFormattable, IParsable<Bits512>, ISpanParsable<Bits512>
    {
        private ulong _w0; // bits 0-63
        private ulong _w1; // bits 64-127
        private ulong _w2; // bits 128-191
        private ulong _w3; // bits 192-255
        private ulong _w4; // bits 256-319
        private ulong _w5; // bits 320-383
        private ulong _w6; // bits 384-447
        private ulong _w7; // bits 448-511

        /// <summary>Number of conceptual words in the backing store.</summary>
        private const int WordCount = 8;

        /// <summary>Total number of defined bits.</summary>
        private const int TotalBits = 512;

        /// <summary>Size of this struct in bytes.</summary>
        public const int SizeInBytes = 64;

        private const ulong LastWordMask = 0xFFFFFFFFFFFFFFFFUL;

        /// <summary>Returns a Bits512 with all bits set to zero.</summary>
        public static Bits512 Zero => default;

        /// <summary>Creates a new Bits512 from a ulong value (zero-extended).</summary>
        public Bits512(ulong value)
        {
            this = default;
            _w0 = value;
        }

        /// <summary>Creates a new Bits512 from an int value. Negative values are sign-extended
        /// to all 512 bits (e.g., -1 sets all bits to 1).</summary>
        public Bits512(int value)
        {
            ulong extended = unchecked((ulong)(long)value);
            ulong fill = value < 0 ? ulong.MaxValue : 0UL;
            _w0 = extended;
            _w1 = fill;
            _w2 = fill;
            _w3 = fill;
            _w4 = fill;
            _w5 = fill;
            _w6 = fill;
            _w7 = fill;
        }

        public partial ulong W0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ulong)_w0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w0 = (ulong)value;
        }

        public partial ulong W1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ulong)_w1;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w1 = (ulong)value;
        }

        public partial ulong W7
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ulong)_w7;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w7 = (ulong)value;
        }

        public partial bool MidFlag
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (_w4 & 0x1UL) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w4 = value ? (_w4 | 0x1UL) : (_w4 & 0xFFFFFFFFFFFFFFFEUL);
        }

        /// <summary>Returns a Bits512 with only the MidFlag bit set.</summary>
        public static Bits512 MidFlagBit
        {
            get
            {
                var result = default(Bits512);
                result._w0 = 0UL;
                result._w1 = 0UL;
                result._w2 = 0UL;
                result._w3 = 0UL;
                result._w4 = 0x1UL;
                result._w5 = 0UL;
                result._w6 = 0UL;
                result._w7 = 0UL;
                return result;
            }
        }

        /// <summary>Returns a Bits512 with the mask for the W0 field (bits 0-63).</summary>
        public static Bits512 W0Mask
        {
            get
            {
                var result = default(Bits512);
                result._w0 = 0xFFFFFFFFFFFFFFFFUL;
                result._w1 = 0UL;
                result._w2 = 0UL;
                result._w3 = 0UL;
                result._w4 = 0UL;
                result._w5 = 0UL;
                result._w6 = 0UL;
                result._w7 = 0UL;
                return result;
            }
        }

        /// <summary>Returns a Bits512 with the mask for the W1 field (bits 64-127).</summary>
        public static Bits512 W1Mask
        {
            get
            {
                var result = default(Bits512);
                result._w0 = 0UL;
                result._w1 = 0xFFFFFFFFFFFFFFFFUL;
                result._w2 = 0UL;
                result._w3 = 0UL;
                result._w4 = 0UL;
                result._w5 = 0UL;
                result._w6 = 0UL;
                result._w7 = 0UL;
                return result;
            }
        }

        /// <summary>Returns a Bits512 with the mask for the W7 field (bits 448-511).</summary>
        public static Bits512 W7Mask
        {
            get
            {
                var result = default(Bits512);
                result._w0 = 0UL;
                result._w1 = 0UL;
                result._w2 = 0UL;
                result._w3 = 0UL;
                result._w4 = 0UL;
                result._w5 = 0UL;
                result._w6 = 0UL;
                result._w7 = 0xFFFFFFFFFFFFFFFFUL;
                return result;
            }
        }

        /// <summary>Returns a new Bits512 with the MidFlag flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits512 WithMidFlag(bool value) { var copy = this; copy.MidFlag = value; return copy; }

        /// <summary>Returns a new Bits512 with the W0 field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits512 WithW0(ulong value) { var copy = this; copy.W0 = value; return copy; }

        /// <summary>Returns a new Bits512 with the W1 field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits512 WithW1(ulong value) { var copy = this; copy.W1 = value; return copy; }

        /// <summary>Returns a new Bits512 with the W7 field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bits512 WithW7(ulong value) { var copy = this; copy.W7 = value; return copy; }

        /// <summary>Metadata for every field and flag declared on this struct, in declaration order.</summary>
        public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]
        {
            new("W0", 0, 64, "ulong", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
            new("W1", 64, 64, "ulong", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
            new("W7", 448, 64, "ulong", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
            new("MidFlag", 256, 1, "bool", true, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb),
        };

        /// <summary>Bitwise complement operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator ~(Bits512 a)
        {
            var result = default(Bits512);
            result._w0 = ~a._w0;
            result._w1 = ~a._w1;
            result._w2 = ~a._w2;
            result._w3 = ~a._w3;
            result._w4 = ~a._w4;
            result._w5 = ~a._w5;
            result._w6 = ~a._w6;
            result._w7 = ~a._w7;
            return result;
        }

        /// <summary>Bitwise OR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator |(Bits512 a, Bits512 b)
        {
            var result = default(Bits512);
            result._w0 = a._w0 | b._w0;
            result._w1 = a._w1 | b._w1;
            result._w2 = a._w2 | b._w2;
            result._w3 = a._w3 | b._w3;
            result._w4 = a._w4 | b._w4;
            result._w5 = a._w5 | b._w5;
            result._w6 = a._w6 | b._w6;
            result._w7 = a._w7 | b._w7;
            return result;
        }

        /// <summary>Bitwise AND operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator &(Bits512 a, Bits512 b)
        {
            var result = default(Bits512);
            result._w0 = a._w0 & b._w0;
            result._w1 = a._w1 & b._w1;
            result._w2 = a._w2 & b._w2;
            result._w3 = a._w3 & b._w3;
            result._w4 = a._w4 & b._w4;
            result._w5 = a._w5 & b._w5;
            result._w6 = a._w6 & b._w6;
            result._w7 = a._w7 & b._w7;
            return result;
        }

        /// <summary>Bitwise XOR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator ^(Bits512 a, Bits512 b)
        {
            var result = default(Bits512);
            result._w0 = a._w0 ^ b._w0;
            result._w1 = a._w1 ^ b._w1;
            result._w2 = a._w2 ^ b._w2;
            result._w3 = a._w3 ^ b._w3;
            result._w4 = a._w4 ^ b._w4;
            result._w5 = a._w5 ^ b._w5;
            result._w6 = a._w6 ^ b._w6;
            result._w7 = a._w7 ^ b._w7;
            return result;
        }

        /// <summary>Bitwise AND operator with ulong (applied to lowest word).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator &(Bits512 a, ulong b)
        {
            var result = default(Bits512);
            result._w0 = a._w0 & b;
            result._w1 = 0UL;
            result._w2 = 0UL;
            result._w3 = 0UL;
            result._w4 = 0UL;
            result._w5 = 0UL;
            result._w6 = 0UL;
            result._w7 = 0UL;
            return result;
        }

        /// <summary>Unary plus operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator +(Bits512 a) => a;

        /// <summary>Unary negation operator. Returns two's complement negation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator -(Bits512 a) => ~a + new Bits512(1UL);

        /// <summary>Addition operator with carry propagation.</summary>
        public static Bits512 operator +(Bits512 a, Bits512 b)
        {
            ulong w0 = a._w0 + b._w0;
            ulong c0 = (w0 < a._w0) ? 1UL : 0UL;
            ulong w1 = a._w1 + b._w1 + c0;
            ulong c1 = (w1 < a._w1 || (c0 != 0 && w1 == a._w1)) ? 1UL : 0UL;
            ulong w2 = a._w2 + b._w2 + c1;
            ulong c2 = (w2 < a._w2 || (c1 != 0 && w2 == a._w2)) ? 1UL : 0UL;
            ulong w3 = a._w3 + b._w3 + c2;
            ulong c3 = (w3 < a._w3 || (c2 != 0 && w3 == a._w3)) ? 1UL : 0UL;
            ulong w4 = a._w4 + b._w4 + c3;
            ulong c4 = (w4 < a._w4 || (c3 != 0 && w4 == a._w4)) ? 1UL : 0UL;
            ulong w5 = a._w5 + b._w5 + c4;
            ulong c5 = (w5 < a._w5 || (c4 != 0 && w5 == a._w5)) ? 1UL : 0UL;
            ulong w6 = a._w6 + b._w6 + c5;
            ulong c6 = (w6 < a._w6 || (c5 != 0 && w6 == a._w6)) ? 1UL : 0UL;
            ulong w7 = a._w7 + b._w7 + c6;
            var result = default(Bits512);
            result._w0 = w0;
            result._w1 = w1;
            result._w2 = w2;
            result._w3 = w3;
            result._w4 = w4;
            result._w5 = w5;
            result._w6 = w6;
            result._w7 = w7;
            return result;
        }

        /// <summary>Addition operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator +(Bits512 a, ulong b) => a + new Bits512(b);

        /// <summary>Subtraction operator with borrow propagation.</summary>
        public static Bits512 operator -(Bits512 a, Bits512 b)
        {
            ulong w0 = a._w0 - b._w0;
            ulong borrow0 = (a._w0 < b._w0) ? 1UL : 0UL;
            ulong diff1 = a._w1 - b._w1;
            ulong w1 = diff1 - borrow0;
            ulong borrow1 = (a._w1 < b._w1 || (borrow0 != 0 && diff1 == 0)) ? 1UL : 0UL;
            ulong diff2 = a._w2 - b._w2;
            ulong w2 = diff2 - borrow1;
            ulong borrow2 = (a._w2 < b._w2 || (borrow1 != 0 && diff2 == 0)) ? 1UL : 0UL;
            ulong diff3 = a._w3 - b._w3;
            ulong w3 = diff3 - borrow2;
            ulong borrow3 = (a._w3 < b._w3 || (borrow2 != 0 && diff3 == 0)) ? 1UL : 0UL;
            ulong diff4 = a._w4 - b._w4;
            ulong w4 = diff4 - borrow3;
            ulong borrow4 = (a._w4 < b._w4 || (borrow3 != 0 && diff4 == 0)) ? 1UL : 0UL;
            ulong diff5 = a._w5 - b._w5;
            ulong w5 = diff5 - borrow4;
            ulong borrow5 = (a._w5 < b._w5 || (borrow4 != 0 && diff5 == 0)) ? 1UL : 0UL;
            ulong diff6 = a._w6 - b._w6;
            ulong w6 = diff6 - borrow5;
            ulong borrow6 = (a._w6 < b._w6 || (borrow5 != 0 && diff6 == 0)) ? 1UL : 0UL;
            ulong diff7 = a._w7 - b._w7;
            ulong w7 = diff7 - borrow6;
            var result = default(Bits512);
            result._w0 = w0;
            result._w1 = w1;
            result._w2 = w2;
            result._w3 = w3;
            result._w4 = w4;
            result._w5 = w5;
            result._w6 = w6;
            result._w7 = w7;
            return result;
        }

        /// <summary>Subtraction operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator -(Bits512 a, ulong b) => a - new Bits512(b);

        /// <summary>Multiplication operator (via BigInteger).</summary>
        public static Bits512 operator *(Bits512 a, Bits512 b) => FromBigInteger(a.ToBigInteger() * b.ToBigInteger());

        /// <summary>Multiplication operator with ulong.</summary>
        public static Bits512 operator *(Bits512 a, ulong b) => FromBigInteger(a.ToBigInteger() * b);

        /// <summary>Multiplication operator with ulong.</summary>
        public static Bits512 operator *(ulong a, Bits512 b) => FromBigInteger(a * b.ToBigInteger());

        /// <summary>Division operator (via BigInteger).</summary>
        public static Bits512 operator /(Bits512 a, Bits512 b) => FromBigInteger(a.ToBigInteger() / b.ToBigInteger());

        /// <summary>Division operator with ulong.</summary>
        public static Bits512 operator /(Bits512 a, ulong b) => FromBigInteger(a.ToBigInteger() / b);

        /// <summary>Modulus operator (via BigInteger).</summary>
        public static Bits512 operator %(Bits512 a, Bits512 b) => FromBigInteger(a.ToBigInteger() % b.ToBigInteger());

        /// <summary>Modulus operator with ulong.</summary>
        public static Bits512 operator %(Bits512 a, ulong b) => FromBigInteger(a.ToBigInteger() % b);

        /// <summary>Left shift operator.</summary>
        public static Bits512 operator <<(Bits512 a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(Bits512);
            for (int dst = WordCount - 1; dst >= 0; dst--)
            {
                int src = dst - wordShift;
                if (src < 0) continue;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, GetWord(result, dst) | (val << bitShift));
                    if (src > 0)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src - 1) >> (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Right shift operator (unsigned).</summary>
        public static Bits512 operator >>(Bits512 a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(Bits512);
            for (int dst = 0; dst < WordCount; dst++)
            {
                int src = dst + wordShift;
                if (src >= WordCount) break;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, val >> bitShift);
                    if (src + 1 < WordCount)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src + 1) << (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Unsigned right shift operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 operator >>>(Bits512 a, int amount) => a >> amount;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong GetWord(Bits512 v, int index)
        {
            return index switch
            {
                0 => v._w0,
                1 => v._w1,
                2 => v._w2,
                3 => v._w3,
                4 => v._w4,
                5 => v._w5,
                6 => v._w6,
                7 => v._w7,
                _ => 0UL,
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void SetWord(ref Bits512 v, int index, ulong value)
        {
            switch (index)
            {
                case 0: v._w0 = value; break;
                case 1: v._w1 = value; break;
                case 2: v._w2 = value; break;
                case 3: v._w3 = value; break;
                case 4: v._w4 = value; break;
                case 5: v._w5 = value; break;
                case 6: v._w6 = value; break;
                case 7: v._w7 = value; break;
            }
        }

        /// <summary>Less than operator.</summary>
        public static bool operator <(Bits512 a, Bits512 b)
        {
            if (a._w7 != b._w7) return a._w7 < b._w7;
            if (a._w6 != b._w6) return a._w6 < b._w6;
            if (a._w5 != b._w5) return a._w5 < b._w5;
            if (a._w4 != b._w4) return a._w4 < b._w4;
            if (a._w3 != b._w3) return a._w3 < b._w3;
            if (a._w2 != b._w2) return a._w2 < b._w2;
            if (a._w1 != b._w1) return a._w1 < b._w1;
            if (a._w0 != b._w0) return a._w0 < b._w0;
            return false;
        }

        /// <summary>Greater than operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(Bits512 a, Bits512 b) => b < a;

        /// <summary>Less than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(Bits512 a, Bits512 b) => !(b < a);

        /// <summary>Greater than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(Bits512 a, Bits512 b) => !(a < b);

        /// <summary>Equality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Bits512 a, Bits512 b) => a._w0 == b._w0 && a._w1 == b._w1 && a._w2 == b._w2 && a._w3 == b._w3 && a._w4 == b._w4 && a._w5 == b._w5 && a._w6 == b._w6 && a._w7 == b._w7;

        /// <summary>Inequality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Bits512 a, Bits512 b) => !(a == b);

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        public override bool Equals(object? obj) => obj is Bits512 other && this == other;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode()
        {
            return HashCode.Combine(_w0, _w1, _w2, _w3, _w4, _w5, _w6, _w7);
        }

        /// <summary>Returns a hex string representation of the value.</summary>
        public override string ToString() => "0x" + ToBigInteger().ToString("X");

        /// <summary>Implicit conversion from ulong (zero-extended).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Bits512(ulong value) => new(value);

        /// <summary>Implicit conversion from int.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Bits512(int value) => new(value);

        /// <summary>Explicit conversion to BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator BigInteger(Bits512 value) => value.ToBigInteger();

        /// <summary>Explicit conversion from BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Bits512(BigInteger value) => FromBigInteger(value);

        /// <summary>Converts this value to a BigInteger.</summary>
        public BigInteger ToBigInteger()
        {
            BigInteger result = _w7;
            result = (result << 64) | _w6;
            result = (result << 64) | _w5;
            result = (result << 64) | _w4;
            result = (result << 64) | _w3;
            result = (result << 64) | _w2;
            result = (result << 64) | _w1;
            result = (result << 64) | _w0;
            return result;
        }

        /// <summary>Creates a Bits512 from a BigInteger (truncated to 512 bits).</summary>
        public static Bits512 FromBigInteger(BigInteger value)
        {
            if (value.Sign < 0) value = (BigInteger.One << TotalBits) + value;
            ulong w0 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w1 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w2 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w3 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w4 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w5 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w6 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w7 = (ulong)(value & ulong.MaxValue);
            var result = default(Bits512);
            result._w0 = w0;
            result._w1 = w1;
            result._w2 = w2;
            result._w3 = w3;
            result._w4 = w4;
            result._w5 = w5;
            result._w6 = w6;
            result._w7 = w7;
            return result;
        }

        /// <summary>Creates a new Bits512 from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public Bits512(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
            _w0 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(0));
            _w1 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(8));
            _w2 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(16));
            _w3 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(24));
            _w4 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(32));
            _w5 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(40));
            _w6 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(48));
            _w7 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(56));
        }

        /// <summary>Creates a new Bits512 by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <returns>The deserialized Bits512.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

        /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public void WriteTo(Span<byte> destination)
        {
            if (destination.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(0), _w0);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(8), _w1);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(16), _w2);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(24), _w3);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(32), _w4);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(40), _w5);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(48), _w6);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(56), _w7);
        }

        /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span.</param>
        /// <param name="bytesWritten">The number of bytes written on success.</param>
        /// <returns>true if the destination span was large enough; otherwise, false.</returns>
        public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < SizeInBytes)
            {
                bytesWritten = 0;
                return false;
            }
            WriteTo(destination);
            bytesWritten = SizeInBytes;
            return true;
        }

        /// <summary>Returns the value as a new little-endian byte array.</summary>
        /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
        public byte[] ToByteArray()
        {
            var bytes = new byte[SizeInBytes];
            WriteTo(bytes);
            return bytes;
        }

        private static bool IsHexPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X');
        private static bool IsBinaryPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B');

        private static string RemoveUnderscores(ReadOnlySpan<char> s)
        {
            bool hasUnderscore = false;
            foreach (var c in s) { if (c == '_') { hasUnderscore = true; break; } }
            if (!hasUnderscore) return s.ToString();
            var sb = new System.Text.StringBuilder(s.Length);
            foreach (var c in s) { if (c != '_') sb.Append(c); }
            return sb.ToString();
        }

        /// <summary>Parses a string into a Bits512. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        public static Bits512 Parse(string s, IFormatProvider? provider)
        {
            ArgumentNullException.ThrowIfNull(s);
            var span = s.AsSpan();
            if (IsBinaryPrefix(span))
            {
                BigInteger val = 0;
                foreach (var c in RemoveUnderscores(span.Slice(2)))
                    val = (val << 1) | (c == '1' ? 1 : 0);
                return FromBigInteger(val);
            }
            if (IsHexPrefix(span))
                return FromBigInteger(BigInteger.Parse("0" + RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider));
            return FromBigInteger(BigInteger.Parse(RemoveUnderscores(span), NumberStyles.Integer, provider));
        }

        /// <summary>Tries to parse a string into a Bits512.</summary>
        public static bool TryParse(string? s, IFormatProvider? provider, out Bits512 result)
        {
            if (s is null) { result = default; return false; }
            try { result = Parse(s, provider); return true; }
            catch { result = default; return false; }
        }

        /// <summary>Parses a span of characters into a Bits512.</summary>
        public static Bits512 Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Parse(s.ToString(), provider);

        /// <summary>Tries to parse a span of characters into a Bits512.</summary>
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Bits512 result) => TryParse(s.ToString(), provider, out result);

        /// <summary>Parses a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bits512 Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

        /// <summary>Tries to parse a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParse(string? s, out Bits512 result) => TryParse(s, CultureInfo.InvariantCulture, out result);

        /// <summary>Formats the value using the specified format and format provider.</summary>
        public string ToString(string? format, IFormatProvider? formatProvider) => ToBigInteger().ToString(format, formatProvider);

        /// <summary>Tries to format the value into the provided span of characters.</summary>
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            var str = ToString(format.ToString(), provider);
            if (str.Length <= destination.Length)
            {
                str.AsSpan().CopyTo(destination);
                charsWritten = str.Length;
                return true;
            }
            charsWritten = 0;
            return false;
        }

        /// <summary>Compares this instance to a specified object.</summary>
        public int CompareTo(object? obj)
        {
            if (obj is null) return 1;
            if (obj is Bits512 other) return CompareTo(other);
            throw new ArgumentException("Object must be of type Bits512", nameof(obj));
        }

        /// <summary>Compares this instance to another Bits512.</summary>
        public int CompareTo(Bits512 other)
        {
            if (_w7 != other._w7) return _w7.CompareTo(other._w7);
            if (_w6 != other._w6) return _w6.CompareTo(other._w6);
            if (_w5 != other._w5) return _w5.CompareTo(other._w5);
            if (_w4 != other._w4) return _w4.CompareTo(other._w4);
            if (_w3 != other._w3) return _w3.CompareTo(other._w3);
            if (_w2 != other._w2) return _w2.CompareTo(other._w2);
            if (_w1 != other._w1) return _w1.CompareTo(other._w1);
            if (_w0 != other._w0) return _w0.CompareTo(other._w0);
            return 0;
        }

        /// <summary>Indicates whether this instance is equal to another Bits512.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Bits512 other) => this == other;

        /// <summary>JSON converter that serializes Bits512 as a hex string.</summary>
        private sealed class Bits512JsonConverter : JsonConverter<Bits512>
        {
            /// <summary>Reads a Bits512 from a JSON string.</summary>
            public override Bits512 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var s = reader.GetString();
                return s is null ? default : Bits512.Parse(s);
            }

            /// <summary>Writes a Bits512 to JSON as a hex string.</summary>
            public override void Write(Utf8JsonWriter writer, Bits512 value, JsonSerializerOptions options)
            {
                writer.WriteStringValue(value.ToString());
            }
        }

    }
}
