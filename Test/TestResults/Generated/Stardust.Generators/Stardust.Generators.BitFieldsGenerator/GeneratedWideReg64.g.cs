// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Buffers.Binary;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Stardust.Utilities.Tests;

[JsonConverter(typeof(GeneratedWideReg64JsonConverter))]
public partial struct GeneratedWideReg64 : IComparable, IComparable<GeneratedWideReg64>, IEquatable<GeneratedWideReg64>,
                             IFormattable, ISpanFormattable, IParsable<GeneratedWideReg64>, ISpanParsable<GeneratedWideReg64>
{
    private ulong Value;

    /// <summary>Size of this struct in bytes.</summary>
    public const int SizeInBytes = 8;

    /// <summary>Returns a GeneratedWideReg64 with all bits set to zero.</summary>
    public static GeneratedWideReg64 Zero => default;

    /// <summary>Creates a new GeneratedWideReg64 with the specified raw bits value.</summary>
    public GeneratedWideReg64(ulong value) { Value = value; }

    public partial byte Status
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => (byte)(Value & 0x00000000000000FFUL);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => Value = (ulong)((Value & 0xFFFFFFFFFFFFFF00UL) | (((ulong)value) & 0x00000000000000FFUL));
    }

    public partial ushort Data
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => (ushort)((Value >> 8) & 0x000000000000FFFFUL);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => Value = (ulong)((Value & 0xFFFFFFFFFF0000FFUL) | ((((ulong)value) << 8) & 0x0000000000FFFF00UL));
    }

    public partial uint Address
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => (uint)((Value >> 24) & 0x00000000FFFFFFFFUL);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => Value = (ulong)((Value & 0xFF00000000FFFFFFUL) | ((((ulong)value) << 24) & 0x00FFFFFFFF000000UL));
    }

    public partial bool Valid
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => (Value & 0x0100000000000000UL) != 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => Value = value ? (ulong)(Value | 0x0100000000000000UL) : (ulong)(Value & 0xFEFFFFFFFFFFFFFFUL);
    }

    public partial bool Ready
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get => (Value & 0x0200000000000000UL) != 0;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set => Value = value ? (ulong)(Value | 0x0200000000000000UL) : (ulong)(Value & 0xFDFFFFFFFFFFFFFFUL);
    }

    /// <summary>Returns a GeneratedWideReg64 with only the Valid bit set.</summary>
    public static GeneratedWideReg64 ValidBit => new((ulong)0x0100000000000000UL);

    /// <summary>Returns a GeneratedWideReg64 with only the Ready bit set.</summary>
    public static GeneratedWideReg64 ReadyBit => new((ulong)0x0200000000000000UL);

    /// <summary>Returns a GeneratedWideReg64 with the mask for the Status field (bits 0-7).</summary>
    public static GeneratedWideReg64 StatusMask => new((ulong)0x00000000000000FFUL);

    /// <summary>Returns a GeneratedWideReg64 with the mask for the Data field (bits 8-23).</summary>
    public static GeneratedWideReg64 DataMask => new((ulong)0x0000000000FFFF00UL);

    /// <summary>Returns a GeneratedWideReg64 with the mask for the Address field (bits 24-55).</summary>
    public static GeneratedWideReg64 AddressMask => new((ulong)0x00FFFFFFFF000000UL);

    /// <summary>Returns a new GeneratedWideReg64 with the Valid flag set to the specified value.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public GeneratedWideReg64 WithValid(bool value) => new(value ? (ulong)(Value | 0x0100000000000000UL) : (ulong)(Value & 0xFEFFFFFFFFFFFFFFUL));

    /// <summary>Returns a new GeneratedWideReg64 with the Ready flag set to the specified value.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public GeneratedWideReg64 WithReady(bool value) => new(value ? (ulong)(Value | 0x0200000000000000UL) : (ulong)(Value & 0xFDFFFFFFFFFFFFFFUL));

    /// <summary>Returns a new GeneratedWideReg64 with the Status field set to the specified value.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public GeneratedWideReg64 WithStatus(byte value) => new((ulong)((Value & 0xFFFFFFFFFFFFFF00UL) | (value & 0x00000000000000FFUL)));

    /// <summary>Returns a new GeneratedWideReg64 with the Data field set to the specified value.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public GeneratedWideReg64 WithData(ushort value) => new((ulong)((Value & 0xFFFFFFFFFF0000FFUL) | (((ulong)value << 8) & 0x0000000000FFFF00UL)));

    /// <summary>Returns a new GeneratedWideReg64 with the Address field set to the specified value.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public GeneratedWideReg64 WithAddress(uint value) => new((ulong)((Value & 0xFF00000000FFFFFFUL) | (((ulong)value << 24) & 0x00FFFFFFFF000000UL)));

    /// <summary>Bitwise complement operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator ~(GeneratedWideReg64 a) => new((ulong)~a.Value);

    /// <summary>Bitwise OR operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator |(GeneratedWideReg64 a, GeneratedWideReg64 b) => new((ulong)(a.Value | b.Value));

    /// <summary>Bitwise AND operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator &(GeneratedWideReg64 a, GeneratedWideReg64 b) => new((ulong)(a.Value & b.Value));

    /// <summary>Bitwise XOR operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator ^(GeneratedWideReg64 a, GeneratedWideReg64 b) => new((ulong)(a.Value ^ b.Value));

    /// <summary>Bitwise AND operator with ulong.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator &(GeneratedWideReg64 a, ulong b) => new(a.Value & b);

    /// <summary>Bitwise AND operator with ulong.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator &(ulong a, GeneratedWideReg64 b) => new(a & b.Value);

    /// <summary>Bitwise OR operator with ulong.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator |(GeneratedWideReg64 a, ulong b) => new(a.Value | b);

    /// <summary>Bitwise OR operator with ulong.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator |(ulong a, GeneratedWideReg64 b) => new(a | b.Value);

    /// <summary>Bitwise XOR operator with ulong.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator ^(GeneratedWideReg64 a, ulong b) => new(a.Value ^ b);

    /// <summary>Bitwise XOR operator with ulong.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator ^(ulong a, GeneratedWideReg64 b) => new(a ^ b.Value);

    /// <summary>Bitwise AND operator with int (widening). Returns ulong for correct semantics.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong operator &(GeneratedWideReg64 a, int b) => a.Value & (ulong)b;

    /// <summary>Bitwise AND operator with int (widening). Returns ulong for correct semantics.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong operator &(int a, GeneratedWideReg64 b) => (ulong)a & b.Value;

    /// <summary>Bitwise OR operator with int (widening). Returns ulong for correct semantics.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong operator |(GeneratedWideReg64 a, int b) => a.Value | (ulong)b;

    /// <summary>Bitwise OR operator with int (widening). Returns ulong for correct semantics.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong operator |(int a, GeneratedWideReg64 b) => (ulong)a | b.Value;

    /// <summary>Bitwise XOR operator with int (widening). Returns ulong for correct semantics.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong operator ^(GeneratedWideReg64 a, int b) => a.Value ^ (ulong)b;

    /// <summary>Bitwise XOR operator with int (widening). Returns ulong for correct semantics.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ulong operator ^(int a, GeneratedWideReg64 b) => (ulong)a ^ b.Value;

    /// <summary>Unary plus operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator +(GeneratedWideReg64 a) => a;

    /// <summary>Unary negation operator. Returns two's complement negation.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator -(GeneratedWideReg64 a) => new(unchecked((ulong)(0 - a.Value)));

    /// <summary>Addition operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator +(GeneratedWideReg64 a, GeneratedWideReg64 b) => new(unchecked((ulong)(a.Value + b.Value)));

    /// <summary>Addition operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator +(GeneratedWideReg64 a, ulong b) => new(unchecked((ulong)(a.Value + b)));

    /// <summary>Addition operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator +(ulong a, GeneratedWideReg64 b) => new(unchecked((ulong)(a + b.Value)));

    /// <summary>Subtraction operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator -(GeneratedWideReg64 a, GeneratedWideReg64 b) => new(unchecked((ulong)(a.Value - b.Value)));

    /// <summary>Subtraction operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator -(GeneratedWideReg64 a, ulong b) => new(unchecked((ulong)(a.Value - b)));

    /// <summary>Subtraction operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator -(ulong a, GeneratedWideReg64 b) => new(unchecked((ulong)(a - b.Value)));

    /// <summary>Multiplication operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator *(GeneratedWideReg64 a, GeneratedWideReg64 b) => new(unchecked((ulong)(a.Value * b.Value)));

    /// <summary>Multiplication operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator *(GeneratedWideReg64 a, ulong b) => new(unchecked((ulong)(a.Value * b)));

    /// <summary>Multiplication operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator *(ulong a, GeneratedWideReg64 b) => new(unchecked((ulong)(a * b.Value)));

    /// <summary>Division operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator /(GeneratedWideReg64 a, GeneratedWideReg64 b) => new((ulong)(a.Value / b.Value));

    /// <summary>Division operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator /(GeneratedWideReg64 a, ulong b) => new((ulong)(a.Value / b));

    /// <summary>Division operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator /(ulong a, GeneratedWideReg64 b) => new((ulong)(a / b.Value));

    /// <summary>Modulus operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator %(GeneratedWideReg64 a, GeneratedWideReg64 b) => new((ulong)(a.Value % b.Value));

    /// <summary>Modulus operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator %(GeneratedWideReg64 a, ulong b) => new((ulong)(a.Value % b));

    /// <summary>Modulus operator with storage type.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator %(ulong a, GeneratedWideReg64 b) => new((ulong)(a % b.Value));

    /// <summary>Left shift operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator <<(GeneratedWideReg64 a, int b) => new(unchecked((ulong)(a.Value << b)));

    /// <summary>Right shift operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator >>(GeneratedWideReg64 a, int b) => new(unchecked((ulong)(a.Value >> b)));

    /// <summary>Unsigned right shift operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 operator >>>(GeneratedWideReg64 a, int b) => new(unchecked((ulong)(a.Value >>> b)));

    /// <summary>Less than operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator <(GeneratedWideReg64 a, GeneratedWideReg64 b) => a.Value < b.Value;

    /// <summary>Greater than operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator >(GeneratedWideReg64 a, GeneratedWideReg64 b) => a.Value > b.Value;

    /// <summary>Less than or equal operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator <=(GeneratedWideReg64 a, GeneratedWideReg64 b) => a.Value <= b.Value;

    /// <summary>Greater than or equal operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator >=(GeneratedWideReg64 a, GeneratedWideReg64 b) => a.Value >= b.Value;

    /// <summary>Equality operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(GeneratedWideReg64 a, GeneratedWideReg64 b) => a.Value == b.Value;

    /// <summary>Inequality operator.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(GeneratedWideReg64 a, GeneratedWideReg64 b) => a.Value != b.Value;

    /// <summary>Determines whether the specified object is equal to the current object.</summary>
    public override bool Equals(object? obj) => obj is GeneratedWideReg64 other && Value == other.Value;

    /// <summary>Returns the hash code for this instance.</summary>
    public override int GetHashCode() => Value.GetHashCode();

    /// <summary>Returns a string representation of the value.</summary>
    public override string ToString() => $"0x{Value:X}";

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator ulong(GeneratedWideReg64 value) => value.Value;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator GeneratedWideReg64(ulong value) => new(value);

    /// <summary>Creates a new GeneratedWideReg64 from a little-endian byte span.</summary>
    /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
    /// <exception cref="ArgumentException">The span is too short.</exception>
    public GeneratedWideReg64(ReadOnlySpan<byte> bytes)
    {
        if (bytes.Length < SizeInBytes)
            throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
        Value = BinaryPrimitives.ReadUInt64LittleEndian(bytes);
    }

    /// <summary>Creates a new GeneratedWideReg64 by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
    /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
    /// <returns>The deserialized GeneratedWideReg64.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

    /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
    /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
    /// <exception cref="ArgumentException">The span is too short.</exception>
    public void WriteTo(Span<byte> destination)
    {
        if (destination.Length < SizeInBytes)
            throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
        BinaryPrimitives.WriteUInt64LittleEndian(destination, Value);
    }

    /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
    /// <param name="destination">The destination span.</param>
    /// <param name="bytesWritten">The number of bytes written on success.</param>
    /// <returns>true if the destination span was large enough; otherwise, false.</returns>
    public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
    {
        if (destination.Length < SizeInBytes)
        {
            bytesWritten = 0;
            return false;
        }
        WriteTo(destination);
        bytesWritten = SizeInBytes;
        return true;
    }

    /// <summary>Returns the value as a new little-endian byte array.</summary>
    /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
    public byte[] ToByteArray()
    {
        var bytes = new byte[SizeInBytes];
        WriteTo(bytes);
        return bytes;
    }

    private static bool IsHexPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X');
    private static bool IsBinaryPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B');

    private static string RemoveUnderscores(ReadOnlySpan<char> s)
    {
        // Fast path: no underscores
        bool hasUnderscore = false;
        foreach (var c in s) { if (c == '_') { hasUnderscore = true; break; } }
        if (!hasUnderscore) return s.ToString();

        // Remove underscores
        var sb = new System.Text.StringBuilder(s.Length);
        foreach (var c in s) { if (c != '_') sb.Append(c); }
        return sb.ToString();
    }

    private static ulong ParseBinary(ReadOnlySpan<char> s)
    {
        var clean = RemoveUnderscores(s);
        return Convert.ToUInt64(clean, 2);
    }

    private static bool TryParseBinary(ReadOnlySpan<char> s, out ulong result)
    {
        try
        {
            result = ParseBinary(s);
            return true;
        }
        catch
        {
            result = default;
            return false;
        }
    }

    /// <summary>Parses a string into a GeneratedWideReg64. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
    /// <param name="s">The string to parse.</param>
    /// <param name="provider">An object that provides culture-specific formatting information.</param>
    /// <returns>The parsed GeneratedWideReg64 value.</returns>
    /// <exception cref="ArgumentNullException">s is null.</exception>
    public static GeneratedWideReg64 Parse(string s, IFormatProvider? provider)
    {
        ArgumentNullException.ThrowIfNull(s);
        var span = s.AsSpan();
        if (IsBinaryPrefix(span))
            return new(ParseBinary(span.Slice(2)));
        if (IsHexPrefix(span))
            return new(ulong.Parse(RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider));
        return new(ulong.Parse(RemoveUnderscores(span), NumberStyles.Integer, provider));
    }

    /// <summary>Tries to parse a string into a GeneratedWideReg64. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
    /// <param name="s">The string to parse.</param>
    /// <param name="provider">An object that provides culture-specific formatting information.</param>
    /// <param name="result">When this method returns, contains the parsed value if successful.</param>
    /// <returns>true if parsing succeeded; otherwise, false.</returns>
    public static bool TryParse(string? s, IFormatProvider? provider, out GeneratedWideReg64 result)
    {
        if (s is null) { result = default; return false; }
        var span = s.AsSpan();
        if (IsBinaryPrefix(span))
        {
            if (TryParseBinary(span.Slice(2), out var binValue))
            {
                result = new(binValue);
                return true;
            }
            result = default;
            return false;
        }
        if (IsHexPrefix(span))
        {
            if (ulong.TryParse(RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider, out var hexValue))
            {
                result = new(hexValue);
                return true;
            }
            result = default;
            return false;
        }
        if (ulong.TryParse(RemoveUnderscores(span), NumberStyles.Integer, provider, out var value))
        {
            result = new(value);
            return true;
        }
        result = default;
        return false;
    }

    /// <summary>Parses a span of characters into a GeneratedWideReg64. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
    /// <param name="s">The span of characters to parse.</param>
    /// <param name="provider">An object that provides culture-specific formatting information.</param>
    /// <returns>The parsed GeneratedWideReg64 value.</returns>
    public static GeneratedWideReg64 Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
    {
        if (IsBinaryPrefix(s))
            return new(ParseBinary(s.Slice(2)));
        if (IsHexPrefix(s))
            return new(ulong.Parse(RemoveUnderscores(s.Slice(2)), NumberStyles.HexNumber, provider));
        return new(ulong.Parse(RemoveUnderscores(s), NumberStyles.Integer, provider));
    }

    /// <summary>Tries to parse a span of characters into a GeneratedWideReg64. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
    /// <param name="s">The span of characters to parse.</param>
    /// <param name="provider">An object that provides culture-specific formatting information.</param>
    /// <param name="result">When this method returns, contains the parsed value if successful.</param>
    /// <returns>true if parsing succeeded; otherwise, false.</returns>
    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out GeneratedWideReg64 result)
    {
        if (IsBinaryPrefix(s))
        {
            if (TryParseBinary(s.Slice(2), out var binValue))
            {
                result = new(binValue);
                return true;
            }
            result = default;
            return false;
        }
        if (IsHexPrefix(s))
        {
            if (ulong.TryParse(RemoveUnderscores(s.Slice(2)), NumberStyles.HexNumber, provider, out var hexValue))
            {
                result = new(hexValue);
                return true;
            }
            result = default;
            return false;
        }
        if (ulong.TryParse(RemoveUnderscores(s), NumberStyles.Integer, provider, out var value))
        {
            result = new(value);
            return true;
        }
        result = default;
        return false;
    }

    /// <summary>Parses a string into a GeneratedWideReg64 using invariant culture. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
    /// <param name="s">The string to parse.</param>
    /// <returns>The parsed GeneratedWideReg64 value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static GeneratedWideReg64 Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

    /// <summary>Tries to parse a string into a GeneratedWideReg64 using invariant culture. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
    /// <param name="s">The string to parse.</param>
    /// <param name="result">When this method returns, contains the parsed value if successful.</param>
    /// <returns>true if parsing succeeded; otherwise, false.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool TryParse(string? s, out GeneratedWideReg64 result) => TryParse(s, CultureInfo.InvariantCulture, out result);

    /// <summary>Formats the value using the specified format and format provider.</summary>
    /// <param name="format">The format to use, or null for the default format.</param>
    /// <param name="formatProvider">The provider to use for culture-specific formatting.</param>
    /// <returns>The formatted string representation of the value.</returns>
    public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);

    /// <summary>Tries to format the value into the provided span of characters.</summary>
    /// <param name="destination">The span to write to.</param>
    /// <param name="charsWritten">The number of characters written.</param>
    /// <param name="format">The format to use.</param>
    /// <param name="provider">The provider to use for culture-specific formatting.</param>
    /// <returns>true if the formatting was successful; otherwise, false.</returns>
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        => Value.TryFormat(destination, out charsWritten, format, provider);

    /// <summary>Compares this instance to a specified object and returns an integer indicating their relative order.</summary>
    /// <param name="obj">An object to compare, or null.</param>
    /// <returns>A value indicating the relative order of the objects being compared.</returns>
    /// <exception cref="ArgumentException">obj is not a GeneratedWideReg64.</exception>
    public int CompareTo(object? obj)
    {
        if (obj is null) return 1;
        if (obj is GeneratedWideReg64 other) return CompareTo(other);
        throw new ArgumentException("Object must be of type GeneratedWideReg64", nameof(obj));
    }

    /// <summary>Compares this instance to another GeneratedWideReg64 and returns an integer indicating their relative order.</summary>
    /// <param name="other">A GeneratedWideReg64 to compare.</param>
    /// <returns>A value indicating the relative order of the instances being compared.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int CompareTo(GeneratedWideReg64 other) => Value.CompareTo(other.Value);

    /// <summary>Indicates whether this instance is equal to another GeneratedWideReg64.</summary>
    /// <param name="other">A GeneratedWideReg64 to compare with this instance.</param>
    /// <returns>true if the two instances are equal; otherwise, false.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Equals(GeneratedWideReg64 other) => Value == other.Value;

    /// <summary>JSON converter that serializes GeneratedWideReg64 as a string.</summary>
    private sealed class GeneratedWideReg64JsonConverter : JsonConverter<GeneratedWideReg64>
    {
        /// <summary>Reads a GeneratedWideReg64 from a JSON string.</summary>
        public override GeneratedWideReg64 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var s = reader.GetString();
            return s is null ? default : GeneratedWideReg64.Parse(s);
        }

        /// <summary>Writes a GeneratedWideReg64 to JSON as a string.</summary>
        public override void Write(Utf8JsonWriter writer, GeneratedWideReg64 value, JsonSerializerOptions options)
        {
            writer.WriteStringValue(value.ToString());
        }
    }

}
