// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Globalization;
using System.Numerics;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Stardust.Utilities.Tests;

public partial class BitFieldSpecializationTests
{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [JsonConverter(typeof(DecimalRegisterJsonConverter))]
    public partial struct DecimalRegister : IComparable, IComparable<DecimalRegister>, IEquatable<DecimalRegister>,
                                 IFormattable, ISpanFormattable, IParsable<DecimalRegister>, ISpanParsable<DecimalRegister>
    {
        private ulong _w0; // bits 0-63
        private ulong _w1; // bits 64-127

        /// <summary>Number of conceptual words in the backing store.</summary>
        private const int WordCount = 2;

        /// <summary>Total number of defined bits.</summary>
        private const int TotalBits = 128;

        /// <summary>Size of this struct in bytes.</summary>
        public const int SizeInBytes = 16;

        private const ulong LastWordMask = 0xFFFFFFFFFFFFFFFFUL;

        /// <summary>Returns a DecimalRegister with all bits set to zero.</summary>
        public static DecimalRegister Zero => default;

        /// <summary>Creates a new DecimalRegister from individual word values.</summary>
        /// <param name="lower">Bits 0-63 (least significant).</param>
        /// <param name="upper">Bits 64-127 (most significant).</param>
        public DecimalRegister(ulong lower, ulong upper)
        {
            _w0 = lower;
            _w1 = upper;
        }

        /// <summary>Creates a new DecimalRegister from a ulong value (zero-extended).</summary>
        public DecimalRegister(ulong value) : this(value, 0UL) { }

        /// <summary>Creates a new DecimalRegister from an int value. Negative values are sign-extended
        /// to all 128 bits (e.g., -1 sets all bits to 1).</summary>
        public DecimalRegister(int value)
        {
            ulong extended = unchecked((ulong)(long)value);
            ulong fill = value < 0 ? ulong.MaxValue : 0UL;
            _w0 = extended;
            _w1 = fill;
        }

        public partial UInt128 Coefficient
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (UInt128)((_w0 >> 0) | ((_w1 & 0xFFFFFFFFUL) << 64));
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                _w0 = (_w0 & 0x0000000000000000UL) | (((ulong)value & 0x0UL) << 0);
                _w1 = (_w1 & 0xFFFFFFFF00000000UL) | (((ulong)value >> 64) & 0xFFFFFFFFUL);
            }
        }

        public partial byte Scale
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (byte)((_w1 >> 48) & 0x7FUL);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w1 = (_w1 & 0xFF80FFFFFFFFFFFFUL) | (((ulong)value << 48) & 0x007F000000000000UL);
        }

        public partial bool Sign
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (_w1 & 0x8000000000000000UL) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w1 = value ? (_w1 | 0x8000000000000000UL) : (_w1 & 0x7FFFFFFFFFFFFFFFUL);
        }

        /// <summary>Returns a DecimalRegister with only the Sign bit set.</summary>
        public static DecimalRegister SignBit => new(0UL, 0x8000000000000000UL);

        /// <summary>Returns a DecimalRegister with the mask for the Coefficient field (bits 0-95).</summary>
        public static DecimalRegister CoefficientMask => new(0xFFFFFFFFFFFFFFFFUL, 0xFFFFFFFFUL);

        /// <summary>Returns a DecimalRegister with the mask for the Scale field (bits 112-118).</summary>
        public static DecimalRegister ScaleMask => new(0UL, 0x7F000000000000UL);

        /// <summary>Returns a new DecimalRegister with the Sign flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DecimalRegister WithSign(bool value) => new(_w0, value ? (_w1 | 0x8000000000000000UL) : (_w1 & 0x7FFFFFFFFFFFFFFFUL));

        /// <summary>Returns a new DecimalRegister with the Coefficient field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DecimalRegister WithCoefficient(UInt128 value) { var copy = this; copy.Coefficient = value; return copy; }

        /// <summary>Returns a new DecimalRegister with the Scale field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DecimalRegister WithScale(byte value) { var copy = this; copy.Scale = value; return copy; }

        /// <summary>Bitwise complement operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator ~(DecimalRegister a) => new(~a._w0, ~a._w1);

        /// <summary>Bitwise OR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator |(DecimalRegister a, DecimalRegister b) => new(a._w0 | b._w0, a._w1 | b._w1);

        /// <summary>Bitwise AND operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator &(DecimalRegister a, DecimalRegister b) => new(a._w0 & b._w0, a._w1 & b._w1);

        /// <summary>Bitwise XOR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator ^(DecimalRegister a, DecimalRegister b) => new(a._w0 ^ b._w0, a._w1 ^ b._w1);

        /// <summary>Bitwise AND operator with ulong (applied to lowest word).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator &(DecimalRegister a, ulong b) => new(a._w0 & b, 0UL);

        /// <summary>Unary plus operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator +(DecimalRegister a) => a;

        /// <summary>Unary negation operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator -(DecimalRegister a) => -(decimal)a;

        /// <summary>Addition operator (decimal arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator +(DecimalRegister a, DecimalRegister b) => (decimal)a + (decimal)b;

        /// <summary>Addition operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator +(DecimalRegister a, decimal b) => (decimal)a + b;

        /// <summary>Addition operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator +(decimal a, DecimalRegister b) => a + (decimal)b;

        /// <summary>Subtraction operator (decimal arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator -(DecimalRegister a, DecimalRegister b) => (decimal)a - (decimal)b;

        /// <summary>Subtraction operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator -(DecimalRegister a, decimal b) => (decimal)a - b;

        /// <summary>Subtraction operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator -(decimal a, DecimalRegister b) => a - (decimal)b;

        /// <summary>Multiplication operator (decimal arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator *(DecimalRegister a, DecimalRegister b) => (decimal)a * (decimal)b;

        /// <summary>Multiplication operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator *(DecimalRegister a, decimal b) => (decimal)a * b;

        /// <summary>Multiplication operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator *(decimal a, DecimalRegister b) => a * (decimal)b;

        /// <summary>Division operator (decimal arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator /(DecimalRegister a, DecimalRegister b) => (decimal)a / (decimal)b;

        /// <summary>Division operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator /(DecimalRegister a, decimal b) => (decimal)a / b;

        /// <summary>Division operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator /(decimal a, DecimalRegister b) => a / (decimal)b;

        /// <summary>Modulus operator (decimal arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator %(DecimalRegister a, DecimalRegister b) => (decimal)a % (decimal)b;

        /// <summary>Modulus operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator %(DecimalRegister a, decimal b) => (decimal)a % b;

        /// <summary>Modulus operator with decimal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator %(decimal a, DecimalRegister b) => a % (decimal)b;

        /// <summary>Left shift operator.</summary>
        public static DecimalRegister operator <<(DecimalRegister a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(DecimalRegister);
            for (int dst = WordCount - 1; dst >= 0; dst--)
            {
                int src = dst - wordShift;
                if (src < 0) continue;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, GetWord(result, dst) | (val << bitShift));
                    if (src > 0)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src - 1) >> (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Right shift operator (unsigned).</summary>
        public static DecimalRegister operator >>(DecimalRegister a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(DecimalRegister);
            for (int dst = 0; dst < WordCount; dst++)
            {
                int src = dst + wordShift;
                if (src >= WordCount) break;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, val >> bitShift);
                    if (src + 1 < WordCount)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src + 1) << (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Unsigned right shift operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister operator >>>(DecimalRegister a, int amount) => a >> amount;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong GetWord(DecimalRegister v, int index)
        {
            return index switch
            {
                0 => v._w0,
                1 => v._w1,
                _ => 0UL,
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void SetWord(ref DecimalRegister v, int index, ulong value)
        {
            switch (index)
            {
                case 0: v._w0 = value; break;
                case 1: v._w1 = value; break;
            }
        }

        /// <summary>Less than operator (decimal comparison).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(DecimalRegister a, DecimalRegister b) => (decimal)a < (decimal)b;

        /// <summary>Greater than operator (decimal comparison).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(DecimalRegister a, DecimalRegister b) => (decimal)a > (decimal)b;

        /// <summary>Less than or equal operator (decimal comparison).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(DecimalRegister a, DecimalRegister b) => (decimal)a <= (decimal)b;

        /// <summary>Greater than or equal operator (decimal comparison).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(DecimalRegister a, DecimalRegister b) => (decimal)a >= (decimal)b;

        /// <summary>Equality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(DecimalRegister a, DecimalRegister b) => a._w0 == b._w0 && a._w1 == b._w1;

        /// <summary>Inequality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(DecimalRegister a, DecimalRegister b) => !(a == b);

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        public override bool Equals(object? obj) => obj is DecimalRegister other && this == other;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode()
        {
            return HashCode.Combine(_w0, _w1);
        }

        /// <summary>Returns the decimal string representation of the value.</summary>
        public override string ToString() => ((decimal)this).ToString();

        /// <summary>Implicit conversion from ulong (zero-extended).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator DecimalRegister(ulong value) => new(value);

        /// <summary>Implicit conversion from int.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator DecimalRegister(int value) => new(value);

        /// <summary>Explicit conversion to BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator BigInteger(DecimalRegister value) => value.ToBigInteger();

        /// <summary>Explicit conversion from BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator DecimalRegister(BigInteger value) => FromBigInteger(value);

        /// <summary>Implicit conversion to decimal.</summary>
        public static implicit operator decimal(DecimalRegister value)
        {
            int lo = (int)(uint)value._w0;
            int mid = (int)(uint)(value._w0 >> 32);
            int hi = (int)(uint)value._w1;
            int flags = (int)(uint)(value._w1 >> 32);
            bool isNegative = (flags & unchecked((int)0x80000000)) != 0;
            byte scale = (byte)((flags >> 16) & 0x7F);
            return new decimal(lo, mid, hi, isNegative, scale);
        }

        /// <summary>Implicit conversion from decimal.</summary>
        public static implicit operator DecimalRegister(decimal value)
        {
            Span<int> bits = stackalloc int[4];
            decimal.GetBits(value, bits);
            ulong w0 = (uint)bits[0] | ((ulong)(uint)bits[1] << 32);
            ulong w1 = (uint)bits[2] | ((ulong)(uint)bits[3] << 32);
            return new(w0, w1);
        }

        /// <summary>Explicit conversion to raw bits (UInt128).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator UInt128(DecimalRegister value) => ((UInt128)value._w1 << 64) | value._w0;

        /// <summary>Explicit conversion from raw bits (UInt128).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator DecimalRegister(UInt128 value) => new((ulong)(value & ulong.MaxValue), (ulong)(value >> 64));

        /// <summary>Converts this value to a BigInteger.</summary>
        public BigInteger ToBigInteger()
        {
            BigInteger result = _w1;
            result = (result << 64) | _w0;
            return result;
        }

        /// <summary>Creates a DecimalRegister from a BigInteger (truncated to 128 bits).</summary>
        public static DecimalRegister FromBigInteger(BigInteger value)
        {
            if (value.Sign < 0) value = (BigInteger.One << TotalBits) + value;
            ulong w0 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w1 = (ulong)(value & ulong.MaxValue);
            return new(w0, w1);
        }

        /// <summary>Creates a new DecimalRegister from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public DecimalRegister(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
            _w0 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(0));
            _w1 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(8));
        }

        /// <summary>Creates a new DecimalRegister by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <returns>The deserialized DecimalRegister.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

        /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public void WriteTo(Span<byte> destination)
        {
            if (destination.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(0), _w0);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(8), _w1);
        }

        /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span.</param>
        /// <param name="bytesWritten">The number of bytes written on success.</param>
        /// <returns>true if the destination span was large enough; otherwise, false.</returns>
        public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < SizeInBytes)
            {
                bytesWritten = 0;
                return false;
            }
            WriteTo(destination);
            bytesWritten = SizeInBytes;
            return true;
        }

        /// <summary>Returns the value as a new little-endian byte array.</summary>
        /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
        public byte[] ToByteArray()
        {
            var bytes = new byte[SizeInBytes];
            WriteTo(bytes);
            return bytes;
        }

        /// <summary>Parses a string into a DecimalRegister by parsing a decimal value.</summary>
        public static DecimalRegister Parse(string s, IFormatProvider? provider)
        {
            ArgumentNullException.ThrowIfNull(s);
            return decimal.Parse(s, provider);
        }

        /// <summary>Tries to parse a string into a DecimalRegister.</summary>
        public static bool TryParse(string? s, IFormatProvider? provider, out DecimalRegister result)
        {
            if (s is not null && decimal.TryParse(s, provider, out var decValue))
            {
                result = decValue;
                return true;
            }
            result = default;
            return false;
        }

        /// <summary>Parses a span of characters into a DecimalRegister.</summary>
        public static DecimalRegister Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
            => decimal.Parse(s, provider);

        /// <summary>Tries to parse a span of characters into a DecimalRegister.</summary>
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out DecimalRegister result)
        {
            if (decimal.TryParse(s, provider, out var decValue))
            {
                result = decValue;
                return true;
            }
            result = default;
            return false;
        }

        /// <summary>Parses a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DecimalRegister Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

        /// <summary>Tries to parse a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParse(string? s, out DecimalRegister result) => TryParse(s, CultureInfo.InvariantCulture, out result);

        /// <summary>Formats the value using the specified format and format provider.</summary>
        public string ToString(string? format, IFormatProvider? formatProvider) => ((decimal)this).ToString(format, formatProvider);

        /// <summary>Tries to format the value into the provided span of characters.</summary>
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
            => ((decimal)this).TryFormat(destination, out charsWritten, format, provider);

        /// <summary>Compares this instance to a specified object.</summary>
        public int CompareTo(object? obj)
        {
            if (obj is null) return 1;
            if (obj is DecimalRegister other) return CompareTo(other);
            throw new ArgumentException("Object must be of type DecimalRegister", nameof(obj));
        }

        /// <summary>Compares this instance to another DecimalRegister.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CompareTo(DecimalRegister other) => ((decimal)this).CompareTo((decimal)other);

        /// <summary>Indicates whether this instance is equal to another DecimalRegister.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(DecimalRegister other) => this == other;

        /// <summary>JSON converter that serializes DecimalRegister as a hex string.</summary>
        private sealed class DecimalRegisterJsonConverter : JsonConverter<DecimalRegister>
        {
            /// <summary>Reads a DecimalRegister from a JSON string.</summary>
            public override DecimalRegister Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var s = reader.GetString();
                return s is null ? default : DecimalRegister.Parse(s);
            }

            /// <summary>Writes a DecimalRegister to JSON as a hex string.</summary>
            public override void Write(Utf8JsonWriter writer, DecimalRegister value, JsonSerializerOptions options)
            {
                writer.WriteStringValue(value.ToString());
            }
        }

    }
}
