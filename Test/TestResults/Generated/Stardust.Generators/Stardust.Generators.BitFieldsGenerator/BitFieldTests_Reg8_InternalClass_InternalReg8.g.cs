// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Buffers.Binary;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace Stardust.Utilities.Tests;

public partial class BitFieldTests
{
    public partial class Reg8_InternalClass
    {
        [JsonConverter(typeof(InternalReg8JsonConverter))]
        public partial struct InternalReg8 : IComparable, IComparable<InternalReg8>, IEquatable<InternalReg8>,
                                     IFormattable, ISpanFormattable, IParsable<InternalReg8>, ISpanParsable<InternalReg8>
        {
            private byte Value;

            /// <summary>Size of this struct in bytes.</summary>
            public const int SizeInBytes = 1;

            /// <summary>Returns a InternalReg8 with all bits set to zero.</summary>
            public static InternalReg8 Zero => default;

            /// <summary>Creates a new InternalReg8 with the specified raw bits value.</summary>
            public InternalReg8(byte value) { Value = value; }

            public partial byte FieldC
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => (byte)((Value >> 3) & 0x03);
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                set => Value = (byte)((Value & 0xE7) | ((((byte)value) << 3) & 0x18));
            }

            public partial bool FlagA
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => (Value & 0x01) != 0;
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                set => Value = value ? (byte)(Value | 0x01) : (byte)(Value & 0xFE);
            }

            public partial bool FlagB
            {
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                get => (Value & 0x02) != 0;
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                set => Value = value ? (byte)(Value | 0x02) : (byte)(Value & 0xFD);
            }

            /// <summary>Returns a InternalReg8 with only the FlagA bit set.</summary>
            public static InternalReg8 FlagABit => new((byte)0x01);

            /// <summary>Returns a InternalReg8 with only the FlagB bit set.</summary>
            public static InternalReg8 FlagBBit => new((byte)0x02);

            /// <summary>Returns a InternalReg8 with the mask for the FieldC field (bits 3-4).</summary>
            public static InternalReg8 FieldCMask => new((byte)0x18);

            /// <summary>Returns a new InternalReg8 with the FlagA flag set to the specified value.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public InternalReg8 WithFlagA(bool value) => new(value ? (byte)(Value | 0x01) : (byte)(Value & 0xFE));

            /// <summary>Returns a new InternalReg8 with the FlagB flag set to the specified value.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public InternalReg8 WithFlagB(bool value) => new(value ? (byte)(Value | 0x02) : (byte)(Value & 0xFD));

            /// <summary>Returns a new InternalReg8 with the FieldC field set to the specified value.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public InternalReg8 WithFieldC(byte value) => new((byte)((Value & 0xE7) | (((byte)value << 3) & 0x18)));

            /// <summary>Bitwise complement operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator ~(InternalReg8 a) => new((byte)~a.Value);

            /// <summary>Bitwise OR operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator |(InternalReg8 a, InternalReg8 b) => new((byte)(a.Value | b.Value));

            /// <summary>Bitwise AND operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator &(InternalReg8 a, InternalReg8 b) => new((byte)(a.Value & b.Value));

            /// <summary>Bitwise XOR operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator ^(InternalReg8 a, InternalReg8 b) => new((byte)(a.Value ^ b.Value));

            /// <summary>Unary plus operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator +(InternalReg8 a) => a;

            /// <summary>Unary negation operator. Returns two's complement negation.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator -(InternalReg8 a) => new(unchecked((byte)(0 - a.Value)));

            /// <summary>Addition operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator +(InternalReg8 a, InternalReg8 b) => new(unchecked((byte)(a.Value + b.Value)));

            /// <summary>Addition operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator +(InternalReg8 a, byte b) => new(unchecked((byte)(a.Value + b)));

            /// <summary>Addition operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator +(byte a, InternalReg8 b) => new(unchecked((byte)(a + b.Value)));

            /// <summary>Subtraction operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator -(InternalReg8 a, InternalReg8 b) => new(unchecked((byte)(a.Value - b.Value)));

            /// <summary>Subtraction operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator -(InternalReg8 a, byte b) => new(unchecked((byte)(a.Value - b)));

            /// <summary>Subtraction operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator -(byte a, InternalReg8 b) => new(unchecked((byte)(a - b.Value)));

            /// <summary>Multiplication operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator *(InternalReg8 a, InternalReg8 b) => new(unchecked((byte)(a.Value * b.Value)));

            /// <summary>Multiplication operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator *(InternalReg8 a, byte b) => new(unchecked((byte)(a.Value * b)));

            /// <summary>Multiplication operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator *(byte a, InternalReg8 b) => new(unchecked((byte)(a * b.Value)));

            /// <summary>Division operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator /(InternalReg8 a, InternalReg8 b) => new((byte)(a.Value / b.Value));

            /// <summary>Division operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator /(InternalReg8 a, byte b) => new((byte)(a.Value / b));

            /// <summary>Division operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator /(byte a, InternalReg8 b) => new((byte)(a / b.Value));

            /// <summary>Modulus operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator %(InternalReg8 a, InternalReg8 b) => new((byte)(a.Value % b.Value));

            /// <summary>Modulus operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator %(InternalReg8 a, byte b) => new((byte)(a.Value % b));

            /// <summary>Modulus operator with storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 operator %(byte a, InternalReg8 b) => new((byte)(a % b.Value));

            /// <summary>Left shift operator. Returns int for intuitive bitwise operations with literals.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static int operator <<(InternalReg8 a, int b) => a.Value << b;

            /// <summary>Right shift operator. Returns int for intuitive bitwise operations with literals.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static int operator >>(InternalReg8 a, int b) => a.Value >> b;

            /// <summary>Unsigned right shift operator. Returns int for intuitive bitwise operations with literals.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static int operator >>>(InternalReg8 a, int b) => a.Value >>> b;

            /// <summary>Less than operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator <(InternalReg8 a, InternalReg8 b) => a.Value < b.Value;

            /// <summary>Greater than operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator >(InternalReg8 a, InternalReg8 b) => a.Value > b.Value;

            /// <summary>Less than or equal operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator <=(InternalReg8 a, InternalReg8 b) => a.Value <= b.Value;

            /// <summary>Greater than or equal operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator >=(InternalReg8 a, InternalReg8 b) => a.Value >= b.Value;

            /// <summary>Equality operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator ==(InternalReg8 a, InternalReg8 b) => a.Value == b.Value;

            /// <summary>Inequality operator.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool operator !=(InternalReg8 a, InternalReg8 b) => a.Value != b.Value;

            /// <summary>Determines whether the specified object is equal to the current object.</summary>
            public override bool Equals(object? obj) => obj is InternalReg8 other && Value == other.Value;

            /// <summary>Returns the hash code for this instance.</summary>
            public override int GetHashCode() => Value.GetHashCode();

            /// <summary>Returns a string representation of the value.</summary>
            public override string ToString() => $"0x{Value:X}";

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static implicit operator byte(InternalReg8 value) => value.Value;

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static implicit operator InternalReg8(byte value) => new(value);

            /// <summary>Implicit conversion from int. Truncates to storage type.</summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static implicit operator InternalReg8(int value) => new(unchecked((byte)value));

            /// <summary>Creates a new InternalReg8 from a little-endian byte span.</summary>
            /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
            /// <exception cref="ArgumentException">The span is too short.</exception>
            public InternalReg8(ReadOnlySpan<byte> bytes)
            {
                if (bytes.Length < SizeInBytes)
                    throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
                Value = bytes[0];
            }

            /// <summary>Creates a new InternalReg8 by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
            /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
            /// <returns>The deserialized InternalReg8.</returns>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

            /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
            /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
            /// <exception cref="ArgumentException">The span is too short.</exception>
            public void WriteTo(Span<byte> destination)
            {
                if (destination.Length < SizeInBytes)
                    throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
                destination[0] = unchecked((byte)Value);
            }

            /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
            /// <param name="destination">The destination span.</param>
            /// <param name="bytesWritten">The number of bytes written on success.</param>
            /// <returns>true if the destination span was large enough; otherwise, false.</returns>
            public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
            {
                if (destination.Length < SizeInBytes)
                {
                    bytesWritten = 0;
                    return false;
                }
                WriteTo(destination);
                bytesWritten = SizeInBytes;
                return true;
            }

            /// <summary>Returns the value as a new little-endian byte array.</summary>
            /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
            public byte[] ToByteArray()
            {
                var bytes = new byte[SizeInBytes];
                WriteTo(bytes);
                return bytes;
            }

            private static bool IsHexPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X');
            private static bool IsBinaryPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B');

            private static string RemoveUnderscores(ReadOnlySpan<char> s)
            {
                // Fast path: no underscores
                bool hasUnderscore = false;
                foreach (var c in s) { if (c == '_') { hasUnderscore = true; break; } }
                if (!hasUnderscore) return s.ToString();

                // Remove underscores
                var sb = new System.Text.StringBuilder(s.Length);
                foreach (var c in s) { if (c != '_') sb.Append(c); }
                return sb.ToString();
            }

            private static byte ParseBinary(ReadOnlySpan<char> s)
            {
                var clean = RemoveUnderscores(s);
                return Convert.ToByte(clean, 2);
            }

            private static bool TryParseBinary(ReadOnlySpan<char> s, out byte result)
            {
                try
                {
                    result = ParseBinary(s);
                    return true;
                }
                catch
                {
                    result = default;
                    return false;
                }
            }

            /// <summary>Parses a string into a InternalReg8. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
            /// <param name="s">The string to parse.</param>
            /// <param name="provider">An object that provides culture-specific formatting information.</param>
            /// <returns>The parsed InternalReg8 value.</returns>
            /// <exception cref="ArgumentNullException">s is null.</exception>
            public static InternalReg8 Parse(string s, IFormatProvider? provider)
            {
                ArgumentNullException.ThrowIfNull(s);
                var span = s.AsSpan();
                if (IsBinaryPrefix(span))
                    return new(ParseBinary(span.Slice(2)));
                if (IsHexPrefix(span))
                    return new(byte.Parse(RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider));
                return new(byte.Parse(RemoveUnderscores(span), NumberStyles.Integer, provider));
            }

            /// <summary>Tries to parse a string into a InternalReg8. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
            /// <param name="s">The string to parse.</param>
            /// <param name="provider">An object that provides culture-specific formatting information.</param>
            /// <param name="result">When this method returns, contains the parsed value if successful.</param>
            /// <returns>true if parsing succeeded; otherwise, false.</returns>
            public static bool TryParse(string? s, IFormatProvider? provider, out InternalReg8 result)
            {
                if (s is null) { result = default; return false; }
                var span = s.AsSpan();
                if (IsBinaryPrefix(span))
                {
                    if (TryParseBinary(span.Slice(2), out var binValue))
                    {
                        result = new(binValue);
                        return true;
                    }
                    result = default;
                    return false;
                }
                if (IsHexPrefix(span))
                {
                    if (byte.TryParse(RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider, out var hexValue))
                    {
                        result = new(hexValue);
                        return true;
                    }
                    result = default;
                    return false;
                }
                if (byte.TryParse(RemoveUnderscores(span), NumberStyles.Integer, provider, out var value))
                {
                    result = new(value);
                    return true;
                }
                result = default;
                return false;
            }

            /// <summary>Parses a span of characters into a InternalReg8. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
            /// <param name="s">The span of characters to parse.</param>
            /// <param name="provider">An object that provides culture-specific formatting information.</param>
            /// <returns>The parsed InternalReg8 value.</returns>
            public static InternalReg8 Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
            {
                if (IsBinaryPrefix(s))
                    return new(ParseBinary(s.Slice(2)));
                if (IsHexPrefix(s))
                    return new(byte.Parse(RemoveUnderscores(s.Slice(2)), NumberStyles.HexNumber, provider));
                return new(byte.Parse(RemoveUnderscores(s), NumberStyles.Integer, provider));
            }

            /// <summary>Tries to parse a span of characters into a InternalReg8. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
            /// <param name="s">The span of characters to parse.</param>
            /// <param name="provider">An object that provides culture-specific formatting information.</param>
            /// <param name="result">When this method returns, contains the parsed value if successful.</param>
            /// <returns>true if parsing succeeded; otherwise, false.</returns>
            public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out InternalReg8 result)
            {
                if (IsBinaryPrefix(s))
                {
                    if (TryParseBinary(s.Slice(2), out var binValue))
                    {
                        result = new(binValue);
                        return true;
                    }
                    result = default;
                    return false;
                }
                if (IsHexPrefix(s))
                {
                    if (byte.TryParse(RemoveUnderscores(s.Slice(2)), NumberStyles.HexNumber, provider, out var hexValue))
                    {
                        result = new(hexValue);
                        return true;
                    }
                    result = default;
                    return false;
                }
                if (byte.TryParse(RemoveUnderscores(s), NumberStyles.Integer, provider, out var value))
                {
                    result = new(value);
                    return true;
                }
                result = default;
                return false;
            }

            /// <summary>Parses a string into a InternalReg8 using invariant culture. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
            /// <param name="s">The string to parse.</param>
            /// <returns>The parsed InternalReg8 value.</returns>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static InternalReg8 Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

            /// <summary>Tries to parse a string into a InternalReg8 using invariant culture. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
            /// <param name="s">The string to parse.</param>
            /// <param name="result">When this method returns, contains the parsed value if successful.</param>
            /// <returns>true if parsing succeeded; otherwise, false.</returns>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool TryParse(string? s, out InternalReg8 result) => TryParse(s, CultureInfo.InvariantCulture, out result);

            /// <summary>Formats the value using the specified format and format provider.</summary>
            /// <param name="format">The format to use, or null for the default format.</param>
            /// <param name="formatProvider">The provider to use for culture-specific formatting.</param>
            /// <returns>The formatted string representation of the value.</returns>
            public string ToString(string? format, IFormatProvider? formatProvider) => Value.ToString(format, formatProvider);

            /// <summary>Tries to format the value into the provided span of characters.</summary>
            /// <param name="destination">The span to write to.</param>
            /// <param name="charsWritten">The number of characters written.</param>
            /// <param name="format">The format to use.</param>
            /// <param name="provider">The provider to use for culture-specific formatting.</param>
            /// <returns>true if the formatting was successful; otherwise, false.</returns>
            public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
                => Value.TryFormat(destination, out charsWritten, format, provider);

            /// <summary>Compares this instance to a specified object and returns an integer indicating their relative order.</summary>
            /// <param name="obj">An object to compare, or null.</param>
            /// <returns>A value indicating the relative order of the objects being compared.</returns>
            /// <exception cref="ArgumentException">obj is not a InternalReg8.</exception>
            public int CompareTo(object? obj)
            {
                if (obj is null) return 1;
                if (obj is InternalReg8 other) return CompareTo(other);
                throw new ArgumentException("Object must be of type InternalReg8", nameof(obj));
            }

            /// <summary>Compares this instance to another InternalReg8 and returns an integer indicating their relative order.</summary>
            /// <param name="other">A InternalReg8 to compare.</param>
            /// <returns>A value indicating the relative order of the instances being compared.</returns>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public int CompareTo(InternalReg8 other) => Value.CompareTo(other.Value);

            /// <summary>Indicates whether this instance is equal to another InternalReg8.</summary>
            /// <param name="other">A InternalReg8 to compare with this instance.</param>
            /// <returns>true if the two instances are equal; otherwise, false.</returns>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool Equals(InternalReg8 other) => Value == other.Value;

            /// <summary>JSON converter that serializes InternalReg8 as a string.</summary>
            private sealed class InternalReg8JsonConverter : JsonConverter<InternalReg8>
            {
                /// <summary>Reads a InternalReg8 from a JSON string.</summary>
                public override InternalReg8 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    var s = reader.GetString();
                    return s is null ? default : InternalReg8.Parse(s);
                }

                /// <summary>Writes a InternalReg8 to JSON as a string.</summary>
                public override void Write(Utf8JsonWriter writer, InternalReg8 value, JsonSerializerOptions options)
                {
                    writer.WriteStringValue(value.ToString());
                }
            }

        }
    }
}
