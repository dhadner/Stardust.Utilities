// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Globalization;
using System.Numerics;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Stardust.Utilities;

namespace Stardust.Utilities.Tests;

public partial class BitFieldMultiWordTests
{
    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    [JsonConverter(typeof(CrossWord128JsonConverter))]
    public partial struct CrossWord128 : IComparable, IComparable<CrossWord128>, IEquatable<CrossWord128>,
                                 IFormattable, ISpanFormattable, IParsable<CrossWord128>, ISpanParsable<CrossWord128>
    {
        private ulong _w0; // bits 0-63
        private ulong _w1; // bits 64-127

        /// <summary>Number of conceptual words in the backing store.</summary>
        private const int WordCount = 2;

        /// <summary>Total number of defined bits.</summary>
        private const int TotalBits = 128;

        /// <summary>Size of this struct in bytes.</summary>
        public const int SizeInBytes = 16;

        private const ulong LastWordMask = 0xFFFFFFFFFFFFFFFFUL;

        /// <summary>Returns a CrossWord128 with all bits set to zero.</summary>
        public static CrossWord128 Zero => default;

        /// <summary>Creates a new CrossWord128 from individual word values.</summary>
        /// <param name="lower">Bits 0-63 (least significant).</param>
        /// <param name="upper">Bits 64-127 (most significant).</param>
        public CrossWord128(ulong lower, ulong upper)
        {
            _w0 = lower;
            _w1 = upper;
        }

        /// <summary>Creates a new CrossWord128 from a ulong value (zero-extended).</summary>
        public CrossWord128(ulong value) : this(value, 0UL) { }

        /// <summary>Creates a new CrossWord128 from an int value. Negative values are sign-extended
        /// to all 128 bits (e.g., -1 sets all bits to 1).</summary>
        public CrossWord128(int value)
        {
            ulong extended = unchecked((ulong)(long)value);
            ulong fill = value < 0 ? ulong.MaxValue : 0UL;
            _w0 = extended;
            _w1 = fill;
        }

        public partial byte CrossField
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (byte)((_w0 >> 60) | ((_w1 & 0xFUL) << 4));
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                _w0 = (_w0 & 0x0FFFFFFFFFFFFFFFUL) | (((ulong)value & 0xFUL) << 60);
                _w1 = (_w1 & 0xFFFFFFFFFFFFFFF0UL) | (((ulong)value >> 4) & 0xFUL);
            }
        }

        public partial bool LowBit
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (_w0 & 0x1UL) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w0 = value ? (_w0 | 0x1UL) : (_w0 & 0xFFFFFFFFFFFFFFFEUL);
        }

        public partial bool HighBit
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (_w1 & 0x8000000000000000UL) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _w1 = value ? (_w1 | 0x8000000000000000UL) : (_w1 & 0x7FFFFFFFFFFFFFFFUL);
        }

        /// <summary>Returns a CrossWord128 with only the LowBit bit set.</summary>
        public static CrossWord128 LowBitBit => new(0x1UL, 0UL);

        /// <summary>Returns a CrossWord128 with only the HighBit bit set.</summary>
        public static CrossWord128 HighBitBit => new(0UL, 0x8000000000000000UL);

        /// <summary>Returns a CrossWord128 with the mask for the CrossField field (bits 60-67).</summary>
        public static CrossWord128 CrossFieldMask => new(0xF000000000000000UL, 0xFUL);

        /// <summary>Returns a new CrossWord128 with the LowBit flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public CrossWord128 WithLowBit(bool value) => new(value ? (_w0 | 0x1UL) : (_w0 & 0xFFFFFFFFFFFFFFFEUL), _w1);

        /// <summary>Returns a new CrossWord128 with the HighBit flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public CrossWord128 WithHighBit(bool value) => new(_w0, value ? (_w1 | 0x8000000000000000UL) : (_w1 & 0x7FFFFFFFFFFFFFFFUL));

        /// <summary>Returns a new CrossWord128 with the CrossField field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public CrossWord128 WithCrossField(byte value) { var copy = this; copy.CrossField = value; return copy; }

        /// <summary>Metadata for every field and flag declared on this struct, in declaration order.</summary>
        public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]
        {
            new("CrossField", 60, 8, "byte", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 128, FieldMustBe: 0, StructUndefinedMustBe: 0),
            new("LowBit", 0, 1, "bool", true, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 128, FieldMustBe: 0, StructUndefinedMustBe: 0),
            new("HighBit", 127, 1, "bool", true, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 128, FieldMustBe: 0, StructUndefinedMustBe: 0),
        };

        /// <summary>Bitwise complement operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator ~(CrossWord128 a) => new(~a._w0, ~a._w1);

        /// <summary>Bitwise OR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator |(CrossWord128 a, CrossWord128 b) => new(a._w0 | b._w0, a._w1 | b._w1);

        /// <summary>Bitwise AND operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator &(CrossWord128 a, CrossWord128 b) => new(a._w0 & b._w0, a._w1 & b._w1);

        /// <summary>Bitwise XOR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator ^(CrossWord128 a, CrossWord128 b) => new(a._w0 ^ b._w0, a._w1 ^ b._w1);

        /// <summary>Bitwise AND operator with ulong (applied to lowest word).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator &(CrossWord128 a, ulong b) => new(a._w0 & b, 0UL);

        /// <summary>Unary plus operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator +(CrossWord128 a) => a;

        /// <summary>Unary negation operator. Returns two's complement negation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator -(CrossWord128 a) => ~a + new CrossWord128(1UL);

        /// <summary>Addition operator with carry propagation.</summary>
        public static CrossWord128 operator +(CrossWord128 a, CrossWord128 b)
        {
            ulong w0 = a._w0 + b._w0;
            ulong c0 = (w0 < a._w0) ? 1UL : 0UL;
            ulong w1 = a._w1 + b._w1 + c0;
            return new(w0, w1);
        }

        /// <summary>Addition operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator +(CrossWord128 a, ulong b) => a + new CrossWord128(b);

        /// <summary>Subtraction operator with borrow propagation.</summary>
        public static CrossWord128 operator -(CrossWord128 a, CrossWord128 b)
        {
            ulong w0 = a._w0 - b._w0;
            ulong borrow0 = (a._w0 < b._w0) ? 1UL : 0UL;
            ulong diff1 = a._w1 - b._w1;
            ulong w1 = diff1 - borrow0;
            return new(w0, w1);
        }

        /// <summary>Subtraction operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator -(CrossWord128 a, ulong b) => a - new CrossWord128(b);

        /// <summary>Multiplication operator (via BigInteger).</summary>
        public static CrossWord128 operator *(CrossWord128 a, CrossWord128 b) => FromBigInteger(a.ToBigInteger() * b.ToBigInteger());

        /// <summary>Multiplication operator with ulong.</summary>
        public static CrossWord128 operator *(CrossWord128 a, ulong b) => FromBigInteger(a.ToBigInteger() * b);

        /// <summary>Multiplication operator with ulong.</summary>
        public static CrossWord128 operator *(ulong a, CrossWord128 b) => FromBigInteger(a * b.ToBigInteger());

        /// <summary>Division operator (via BigInteger).</summary>
        public static CrossWord128 operator /(CrossWord128 a, CrossWord128 b) => FromBigInteger(a.ToBigInteger() / b.ToBigInteger());

        /// <summary>Division operator with ulong.</summary>
        public static CrossWord128 operator /(CrossWord128 a, ulong b) => FromBigInteger(a.ToBigInteger() / b);

        /// <summary>Modulus operator (via BigInteger).</summary>
        public static CrossWord128 operator %(CrossWord128 a, CrossWord128 b) => FromBigInteger(a.ToBigInteger() % b.ToBigInteger());

        /// <summary>Modulus operator with ulong.</summary>
        public static CrossWord128 operator %(CrossWord128 a, ulong b) => FromBigInteger(a.ToBigInteger() % b);

        /// <summary>Left shift operator.</summary>
        public static CrossWord128 operator <<(CrossWord128 a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(CrossWord128);
            for (int dst = WordCount - 1; dst >= 0; dst--)
            {
                int src = dst - wordShift;
                if (src < 0) continue;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, GetWord(result, dst) | (val << bitShift));
                    if (src > 0)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src - 1) >> (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Right shift operator (unsigned).</summary>
        public static CrossWord128 operator >>(CrossWord128 a, int amount)
        {
            if (amount <= 0) return a;
            if (amount >= TotalBits) return default;
            int wordShift = amount / 64;
            int bitShift = amount % 64;
            var result = default(CrossWord128);
            for (int dst = 0; dst < WordCount; dst++)
            {
                int src = dst + wordShift;
                if (src >= WordCount) break;
                ulong val = GetWord(a, src);
                if (bitShift == 0)
                    SetWord(ref result, dst, val);
                else
                {
                    SetWord(ref result, dst, val >> bitShift);
                    if (src + 1 < WordCount)
                        SetWord(ref result, dst, GetWord(result, dst) | (GetWord(a, src + 1) << (64 - bitShift)));
                }
            }
            return result;
        }

        /// <summary>Unsigned right shift operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 operator >>>(CrossWord128 a, int amount) => a >> amount;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ulong GetWord(CrossWord128 v, int index)
        {
            return index switch
            {
                0 => v._w0,
                1 => v._w1,
                _ => 0UL,
            };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void SetWord(ref CrossWord128 v, int index, ulong value)
        {
            switch (index)
            {
                case 0: v._w0 = value; break;
                case 1: v._w1 = value; break;
            }
        }

        /// <summary>Less than operator.</summary>
        public static bool operator <(CrossWord128 a, CrossWord128 b)
        {
            if (a._w1 != b._w1) return a._w1 < b._w1;
            if (a._w0 != b._w0) return a._w0 < b._w0;
            return false;
        }

        /// <summary>Greater than operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(CrossWord128 a, CrossWord128 b) => b < a;

        /// <summary>Less than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(CrossWord128 a, CrossWord128 b) => !(b < a);

        /// <summary>Greater than or equal operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(CrossWord128 a, CrossWord128 b) => !(a < b);

        /// <summary>Equality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(CrossWord128 a, CrossWord128 b) => a._w0 == b._w0 && a._w1 == b._w1;

        /// <summary>Inequality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(CrossWord128 a, CrossWord128 b) => !(a == b);

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        public override bool Equals(object? obj) => obj is CrossWord128 other && this == other;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode()
        {
            return HashCode.Combine(_w0, _w1);
        }

        /// <summary>Returns a hex string representation of the value.</summary>
        public override string ToString() => "0x" + ToBigInteger().ToString("X");

        /// <summary>Implicit conversion from ulong (zero-extended).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator CrossWord128(ulong value) => new(value);

        /// <summary>Implicit conversion from int.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator CrossWord128(int value) => new(value);

        /// <summary>Explicit conversion to BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator BigInteger(CrossWord128 value) => value.ToBigInteger();

        /// <summary>Explicit conversion from BigInteger.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator CrossWord128(BigInteger value) => FromBigInteger(value);

        /// <summary>Converts this value to a BigInteger.</summary>
        public BigInteger ToBigInteger()
        {
            BigInteger result = _w1;
            result = (result << 64) | _w0;
            return result;
        }

        /// <summary>Creates a CrossWord128 from a BigInteger (truncated to 128 bits).</summary>
        public static CrossWord128 FromBigInteger(BigInteger value)
        {
            if (value.Sign < 0) value = (BigInteger.One << TotalBits) + value;
            ulong w0 = (ulong)(value & ulong.MaxValue);
            value >>= 64;
            ulong w1 = (ulong)(value & ulong.MaxValue);
            return new(w0, w1);
        }

        /// <summary>Creates a new CrossWord128 from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public CrossWord128(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
            _w0 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(0));
            _w1 = BinaryPrimitives.ReadUInt64LittleEndian(bytes.Slice(8));
        }

        /// <summary>Creates a new CrossWord128 by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <returns>The deserialized CrossWord128.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

        /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public void WriteTo(Span<byte> destination)
        {
            if (destination.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(0), _w0);
            BinaryPrimitives.WriteUInt64LittleEndian(destination.Slice(8), _w1);
        }

        /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span.</param>
        /// <param name="bytesWritten">The number of bytes written on success.</param>
        /// <returns>true if the destination span was large enough; otherwise, false.</returns>
        public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < SizeInBytes)
            {
                bytesWritten = 0;
                return false;
            }
            WriteTo(destination);
            bytesWritten = SizeInBytes;
            return true;
        }

        /// <summary>Returns the value as a new little-endian byte array.</summary>
        /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
        public byte[] ToByteArray()
        {
            var bytes = new byte[SizeInBytes];
            WriteTo(bytes);
            return bytes;
        }

        private static bool IsHexPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X');
        private static bool IsBinaryPrefix(ReadOnlySpan<char> s) => s.Length >= 2 && s[0] == '0' && (s[1] == 'b' || s[1] == 'B');

        private static string RemoveUnderscores(ReadOnlySpan<char> s)
        {
            bool hasUnderscore = false;
            foreach (var c in s) { if (c == '_') { hasUnderscore = true; break; } }
            if (!hasUnderscore) return s.ToString();
            var sb = new System.Text.StringBuilder(s.Length);
            foreach (var c in s) { if (c != '_') sb.Append(c); }
            return sb.ToString();
        }

        /// <summary>Parses a string into a CrossWord128. Supports decimal, hex (0x prefix), and binary (0b prefix) formats with optional underscores.</summary>
        public static CrossWord128 Parse(string s, IFormatProvider? provider)
        {
            ArgumentNullException.ThrowIfNull(s);
            var span = s.AsSpan();
            if (IsBinaryPrefix(span))
            {
                BigInteger val = 0;
                foreach (var c in RemoveUnderscores(span.Slice(2)))
                    val = (val << 1) | (c == '1' ? 1 : 0);
                return FromBigInteger(val);
            }
            if (IsHexPrefix(span))
                return FromBigInteger(BigInteger.Parse("0" + RemoveUnderscores(span.Slice(2)), NumberStyles.HexNumber, provider));
            return FromBigInteger(BigInteger.Parse(RemoveUnderscores(span), NumberStyles.Integer, provider));
        }

        /// <summary>Tries to parse a string into a CrossWord128.</summary>
        public static bool TryParse(string? s, IFormatProvider? provider, out CrossWord128 result)
        {
            if (s is null) { result = default; return false; }
            try { result = Parse(s, provider); return true; }
            catch { result = default; return false; }
        }

        /// <summary>Parses a span of characters into a CrossWord128.</summary>
        public static CrossWord128 Parse(ReadOnlySpan<char> s, IFormatProvider? provider) => Parse(s.ToString(), provider);

        /// <summary>Tries to parse a span of characters into a CrossWord128.</summary>
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out CrossWord128 result) => TryParse(s.ToString(), provider, out result);

        /// <summary>Parses a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static CrossWord128 Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

        /// <summary>Tries to parse a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParse(string? s, out CrossWord128 result) => TryParse(s, CultureInfo.InvariantCulture, out result);

        /// <summary>Formats the value using the specified format and format provider.</summary>
        public string ToString(string? format, IFormatProvider? formatProvider) => ToBigInteger().ToString(format, formatProvider);

        /// <summary>Tries to format the value into the provided span of characters.</summary>
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            var str = ToString(format.ToString(), provider);
            if (str.Length <= destination.Length)
            {
                str.AsSpan().CopyTo(destination);
                charsWritten = str.Length;
                return true;
            }
            charsWritten = 0;
            return false;
        }

        /// <summary>Compares this instance to a specified object.</summary>
        public int CompareTo(object? obj)
        {
            if (obj is null) return 1;
            if (obj is CrossWord128 other) return CompareTo(other);
            throw new ArgumentException("Object must be of type CrossWord128", nameof(obj));
        }

        /// <summary>Compares this instance to another CrossWord128.</summary>
        public int CompareTo(CrossWord128 other)
        {
            if (_w1 != other._w1) return _w1.CompareTo(other._w1);
            if (_w0 != other._w0) return _w0.CompareTo(other._w0);
            return 0;
        }

        /// <summary>Indicates whether this instance is equal to another CrossWord128.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(CrossWord128 other) => this == other;

        /// <summary>JSON converter that serializes CrossWord128 as a hex string.</summary>
        private sealed class CrossWord128JsonConverter : JsonConverter<CrossWord128>
        {
            /// <summary>Reads a CrossWord128 from a JSON string.</summary>
            public override CrossWord128 Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var s = reader.GetString();
                return s is null ? default : CrossWord128.Parse(s);
            }

            /// <summary>Writes a CrossWord128 to JSON as a hex string.</summary>
            public override void Write(Utf8JsonWriter writer, CrossWord128 value, JsonSerializerOptions options)
            {
                writer.WriteStringValue(value.ToString());
            }
        }

    }
}
