// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
#pragma warning disable CS0675
using System;
using System.Buffers.Binary;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization;
using Stardust.Utilities;

namespace Stardust.Utilities.Tests;

public partial class BitFieldSpecializationTests
{
    [JsonConverter(typeof(DoubleRegisterJsonConverter))]
    public partial struct DoubleRegister : IComparable, IComparable<DoubleRegister>, IEquatable<DoubleRegister>,
                                 IFormattable, ISpanFormattable, IParsable<DoubleRegister>, ISpanParsable<DoubleRegister>
    {
        private ulong Value;

        /// <summary>Size of this struct in bytes.</summary>
        public const int SizeInBytes = 8;

        /// <summary>Returns a DoubleRegister with all bits set to zero.</summary>
        public static DoubleRegister Zero => default;

        /// <summary>Creates a new DoubleRegister with the specified raw bits value.</summary>
        public DoubleRegister(ulong value) { Value = value; }

        /// <summary>Creates a new DoubleRegister from a double value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DoubleRegister(double value) : this(BitConverter.DoubleToUInt64Bits(value)) { }

        public partial ulong Mantissa
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ulong)(Value & 0x000FFFFFFFFFFFFFUL);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = (ulong)((Value & 0xFFF0000000000000UL) | (((ulong)value) & 0x000FFFFFFFFFFFFFUL));
        }

        public partial ushort Exponent
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (ushort)((Value >> 52) & 0x00000000000007FFUL);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = (ulong)((Value & 0x800FFFFFFFFFFFFFUL) | ((((ulong)value) << 52) & 0x7FF0000000000000UL));
        }

        public partial bool Sign
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Value & 0x8000000000000000UL) != 0;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Value = value ? (ulong)(Value | 0x8000000000000000UL) : (ulong)(Value & 0x7FFFFFFFFFFFFFFFUL);
        }

        /// <summary>Returns a DoubleRegister with only the Sign bit set.</summary>
        public static DoubleRegister SignBit => new((ulong)0x8000000000000000UL);

        /// <summary>Returns a DoubleRegister with the mask for the Mantissa field (bits 0-51).</summary>
        public static DoubleRegister MantissaMask => new((ulong)0x000FFFFFFFFFFFFFUL);

        /// <summary>Returns a DoubleRegister with the mask for the Exponent field (bits 52-62).</summary>
        public static DoubleRegister ExponentMask => new((ulong)0x7FF0000000000000UL);

        /// <summary>Metadata for every field and flag declared on this struct, in declaration order.</summary>
        public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]
        {
            new("Mantissa", 0, 52, "ulong", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 64, FieldMustBe: 0, StructUndefinedMustBe: 0),
            new("Exponent", 52, 11, "ushort", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 64, FieldMustBe: 0, StructUndefinedMustBe: 0),
            new("Sign", 63, 1, "bool", true, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 64, FieldMustBe: 0, StructUndefinedMustBe: 0),
        };

        /// <summary>Returns a new DoubleRegister with the Sign flag set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DoubleRegister WithSign(bool value) => new(value ? (ulong)(Value | 0x8000000000000000UL) : (ulong)(Value & 0x7FFFFFFFFFFFFFFFUL));

        /// <summary>Returns a new DoubleRegister with the Mantissa field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DoubleRegister WithMantissa(ulong value) => new((ulong)((Value & 0xFFF0000000000000UL) | (value & 0x000FFFFFFFFFFFFFUL)));

        /// <summary>Returns a new DoubleRegister with the Exponent field set to the specified value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DoubleRegister WithExponent(ushort value) => new((ulong)((Value & 0x800FFFFFFFFFFFFFUL) | (((ulong)value << 52) & 0x7FF0000000000000UL)));

        /// <summary>Bitwise complement operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator ~(DoubleRegister a) => new((ulong)~a.Value);

        /// <summary>Bitwise OR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator |(DoubleRegister a, DoubleRegister b) => new((ulong)(a.Value | b.Value));

        /// <summary>Bitwise AND operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator &(DoubleRegister a, DoubleRegister b) => new((ulong)(a.Value & b.Value));

        /// <summary>Bitwise XOR operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator ^(DoubleRegister a, DoubleRegister b) => new((ulong)(a.Value ^ b.Value));

        /// <summary>Bitwise AND operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator &(DoubleRegister a, ulong b) => new(a.Value & b);

        /// <summary>Bitwise AND operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator &(ulong a, DoubleRegister b) => new(a & b.Value);

        /// <summary>Bitwise OR operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator |(DoubleRegister a, ulong b) => new(a.Value | b);

        /// <summary>Bitwise OR operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator |(ulong a, DoubleRegister b) => new(a | b.Value);

        /// <summary>Bitwise XOR operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator ^(DoubleRegister a, ulong b) => new(a.Value ^ b);

        /// <summary>Bitwise XOR operator with ulong.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator ^(ulong a, DoubleRegister b) => new(a ^ b.Value);

        /// <summary>Bitwise AND operator with int (widening). Returns ulong for correct semantics.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong operator &(DoubleRegister a, int b) => a.Value & (ulong)b;

        /// <summary>Bitwise AND operator with int (widening). Returns ulong for correct semantics.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong operator &(int a, DoubleRegister b) => (ulong)a & b.Value;

        /// <summary>Bitwise OR operator with int (widening). Returns ulong for correct semantics.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong operator |(DoubleRegister a, int b) => a.Value | (ulong)b;

        /// <summary>Bitwise OR operator with int (widening). Returns ulong for correct semantics.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong operator |(int a, DoubleRegister b) => (ulong)a | b.Value;

        /// <summary>Bitwise XOR operator with int (widening). Returns ulong for correct semantics.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong operator ^(DoubleRegister a, int b) => a.Value ^ (ulong)b;

        /// <summary>Bitwise XOR operator with int (widening). Returns ulong for correct semantics.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong operator ^(int a, DoubleRegister b) => (ulong)a ^ b.Value;

        /// <summary>Unary plus operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator +(DoubleRegister a) => a;

        /// <summary>Unary negation operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator -(DoubleRegister a) => new(BitConverter.DoubleToUInt64Bits(-BitConverter.UInt64BitsToDouble(a.Value)));

        /// <summary>Addition operator (floating-point arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator +(DoubleRegister a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) + BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Addition operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator +(DoubleRegister a, double b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) + b));

        /// <summary>Addition operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator +(double a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(a + BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Subtraction operator (floating-point arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator -(DoubleRegister a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) - BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Subtraction operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator -(DoubleRegister a, double b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) - b));

        /// <summary>Subtraction operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator -(double a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(a - BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Multiplication operator (floating-point arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator *(DoubleRegister a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) * BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Multiplication operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator *(DoubleRegister a, double b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) * b));

        /// <summary>Multiplication operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator *(double a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(a * BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Division operator (floating-point arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator /(DoubleRegister a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) / BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Division operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator /(DoubleRegister a, double b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) / b));

        /// <summary>Division operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator /(double a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(a / BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Modulus operator (floating-point arithmetic).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator %(DoubleRegister a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) % BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Modulus operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator %(DoubleRegister a, double b) => new(BitConverter.DoubleToUInt64Bits(BitConverter.UInt64BitsToDouble(a.Value) % b));

        /// <summary>Modulus operator with double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator %(double a, DoubleRegister b) => new(BitConverter.DoubleToUInt64Bits(a % BitConverter.UInt64BitsToDouble(b.Value)));

        /// <summary>Left shift operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator <<(DoubleRegister a, int b) => new(unchecked((ulong)(a.Value << b)));

        /// <summary>Right shift operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator >>(DoubleRegister a, int b) => new(unchecked((ulong)(a.Value >> b)));

        /// <summary>Unsigned right shift operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister operator >>>(DoubleRegister a, int b) => new(unchecked((ulong)(a.Value >>> b)));

        /// <summary>Less than operator (floating-point comparison).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <(DoubleRegister a, DoubleRegister b) => BitConverter.UInt64BitsToDouble(a.Value) < BitConverter.UInt64BitsToDouble(b.Value);

        /// <summary>Greater than operator (floating-point comparison).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >(DoubleRegister a, DoubleRegister b) => BitConverter.UInt64BitsToDouble(a.Value) > BitConverter.UInt64BitsToDouble(b.Value);

        /// <summary>Less than or equal operator (floating-point comparison).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator <=(DoubleRegister a, DoubleRegister b) => BitConverter.UInt64BitsToDouble(a.Value) <= BitConverter.UInt64BitsToDouble(b.Value);

        /// <summary>Greater than or equal operator (floating-point comparison).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator >=(DoubleRegister a, DoubleRegister b) => BitConverter.UInt64BitsToDouble(a.Value) >= BitConverter.UInt64BitsToDouble(b.Value);

        /// <summary>Equality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(DoubleRegister a, DoubleRegister b) => a.Value == b.Value;

        /// <summary>Inequality operator.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(DoubleRegister a, DoubleRegister b) => a.Value != b.Value;

        /// <summary>Determines whether the specified object is equal to the current object.</summary>
        public override bool Equals(object? obj) => obj is DoubleRegister other && Value == other.Value;

        /// <summary>Returns the hash code for this instance.</summary>
        public override int GetHashCode() => Value.GetHashCode();

        /// <summary>Returns a string representation of the value.</summary>
        public override string ToString() => BitConverter.UInt64BitsToDouble(Value).ToString();

        /// <summary>Implicit conversion to double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator double(DoubleRegister value) => BitConverter.UInt64BitsToDouble(value.Value);

        /// <summary>Implicit conversion from double.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator DoubleRegister(double value) => new(BitConverter.DoubleToUInt64Bits(value));

        /// <summary>Explicit conversion to raw bits (ulong).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator ulong(DoubleRegister value) => value.Value;

        /// <summary>Explicit conversion from raw bits (ulong).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator DoubleRegister(ulong value) => new(value);

        /// <summary>Creates a new DoubleRegister from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public DoubleRegister(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(bytes));
            Value = BinaryPrimitives.ReadUInt64LittleEndian(bytes);
        }

        /// <summary>Creates a new DoubleRegister by reading <see cref="SizeInBytes"/> bytes from a little-endian byte span.</summary>
        /// <param name="bytes">The source span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <returns>The deserialized DoubleRegister.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister ReadFrom(ReadOnlySpan<byte> bytes) => new(bytes);

        /// <summary>Writes the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The span is too short.</exception>
        public void WriteTo(Span<byte> destination)
        {
            if (destination.Length < SizeInBytes)
                throw new ArgumentException($"Span must contain at least {SizeInBytes} bytes.", nameof(destination));
            BinaryPrimitives.WriteUInt64LittleEndian(destination, Value);
        }

        /// <summary>Attempts to write the value as little-endian bytes into the destination span.</summary>
        /// <param name="destination">The destination span.</param>
        /// <param name="bytesWritten">The number of bytes written on success.</param>
        /// <returns>true if the destination span was large enough; otherwise, false.</returns>
        public bool TryWriteTo(Span<byte> destination, out int bytesWritten)
        {
            if (destination.Length < SizeInBytes)
            {
                bytesWritten = 0;
                return false;
            }
            WriteTo(destination);
            bytesWritten = SizeInBytes;
            return true;
        }

        /// <summary>Returns the value as a new little-endian byte array.</summary>
        /// <returns>A byte array of length <see cref="SizeInBytes"/>.</returns>
        public byte[] ToByteArray()
        {
            var bytes = new byte[SizeInBytes];
            WriteTo(bytes);
            return bytes;
        }

        /// <summary>Parses a string into a DoubleRegister by parsing a double value.</summary>
        public static DoubleRegister Parse(string s, IFormatProvider? provider)
        {
            ArgumentNullException.ThrowIfNull(s);
            return new(BitConverter.DoubleToUInt64Bits(double.Parse(s, provider)));
        }

        /// <summary>Tries to parse a string into a DoubleRegister.</summary>
        public static bool TryParse(string? s, IFormatProvider? provider, out DoubleRegister result)
        {
            if (s is not null && double.TryParse(s, provider, out var fpValue))
            {
                result = new(BitConverter.DoubleToUInt64Bits(fpValue));
                return true;
            }
            result = default;
            return false;
        }

        /// <summary>Parses a span of characters into a DoubleRegister.</summary>
        public static DoubleRegister Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
            => new(BitConverter.DoubleToUInt64Bits(double.Parse(s, provider)));

        /// <summary>Tries to parse a span of characters into a DoubleRegister.</summary>
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out DoubleRegister result)
        {
            if (double.TryParse(s, provider, out var fpValue))
            {
                result = new(BitConverter.DoubleToUInt64Bits(fpValue));
                return true;
            }
            result = default;
            return false;
        }

        /// <summary>Parses a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static DoubleRegister Parse(string s) => Parse(s, CultureInfo.InvariantCulture);

        /// <summary>Tries to parse a string using invariant culture.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool TryParse(string? s, out DoubleRegister result) => TryParse(s, CultureInfo.InvariantCulture, out result);

        /// <summary>Formats the value using the specified format and format provider.</summary>
        /// <param name="format">The format to use, or null for the default format.</param>
        /// <param name="formatProvider">The provider to use for culture-specific formatting.</param>
        /// <returns>The formatted string representation of the value.</returns>
        public string ToString(string? format, IFormatProvider? formatProvider) => BitConverter.UInt64BitsToDouble(Value).ToString(format, formatProvider);

        /// <summary>Tries to format the value into the provided span of characters.</summary>
        /// <param name="destination">The span to write to.</param>
        /// <param name="charsWritten">The number of characters written.</param>
        /// <param name="format">The format to use.</param>
        /// <param name="provider">The provider to use for culture-specific formatting.</param>
        /// <returns>true if the formatting was successful; otherwise, false.</returns>
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
            => Value.TryFormat(destination, out charsWritten, format, provider);

        /// <summary>Compares this instance to a specified object and returns an integer indicating their relative order.</summary>
        /// <param name="obj">An object to compare, or null.</param>
        /// <returns>A value indicating the relative order of the objects being compared.</returns>
        /// <exception cref="ArgumentException">obj is not a DoubleRegister.</exception>
        public int CompareTo(object? obj)
        {
            if (obj is null) return 1;
            if (obj is DoubleRegister other) return CompareTo(other);
            throw new ArgumentException("Object must be of type DoubleRegister", nameof(obj));
        }

        /// <summary>Compares this instance to another DoubleRegister and returns an integer indicating their relative order.</summary>
        /// <param name="other">A DoubleRegister to compare.</param>
        /// <returns>A value indicating the relative order of the instances being compared.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int CompareTo(DoubleRegister other) => BitConverter.UInt64BitsToDouble(Value).CompareTo(BitConverter.UInt64BitsToDouble(other.Value));

        /// <summary>Indicates whether this instance is equal to another DoubleRegister.</summary>
        /// <param name="other">A DoubleRegister to compare with this instance.</param>
        /// <returns>true if the two instances are equal; otherwise, false.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(DoubleRegister other) => Value == other.Value;

        /// <summary>JSON converter that serializes DoubleRegister as a string.</summary>
        private sealed class DoubleRegisterJsonConverter : JsonConverter<DoubleRegister>
        {
            /// <summary>Reads a DoubleRegister from a JSON string.</summary>
            public override DoubleRegister Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                var s = reader.GetString();
                return s is null ? default : DoubleRegister.Parse(s);
            }

            /// <summary>Writes a DoubleRegister to JSON as a string.</summary>
            public override void Write(Utf8JsonWriter writer, DoubleRegister value, JsonSerializerOptions options)
            {
                writer.WriteStringValue(value.ToString());
            }
        }

    }
}
