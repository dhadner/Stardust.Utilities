// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
using System;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using Stardust.Utilities;

namespace Stardust.Utilities.Protocols;

public partial record struct TcpHeaderView
{
    private readonly Memory<byte> _data;
    private readonly byte _bitOffset;

    /// <summary>Minimum number of bytes required in the backing buffer.</summary>
    public const int SizeInBytes = 20;

    /// <summary>Creates a view over the specified memory buffer.</summary>
    /// <param name="data">The buffer to view. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
    /// <exception cref="ArgumentException">The buffer is too short.</exception>
    public TcpHeaderView(Memory<byte> data)
    {
        if (data.Length < SizeInBytes)
            throw new ArgumentException($"Buffer must contain at least {SizeInBytes} bytes, but was {data.Length}.", nameof(data));
        _data = data;
        _bitOffset = 0;
    }

    /// <summary>Creates a view over the specified byte array.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TcpHeaderView(byte[] data) : this(data.AsMemory()) { }

    /// <summary>Creates a view over a portion of the specified byte array.</summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TcpHeaderView(byte[] data, int offset) : this(data.AsMemory(offset)) { }

    /// <summary>Creates a sub-view at a bit offset within the specified memory buffer (used by nested views).</summary>
    internal TcpHeaderView(Memory<byte> data, int bitOffset)
    {
        _data = data;
        _bitOffset = (byte)bitOffset;
    }

    /// <summary>Gets the underlying memory buffer.</summary>
    public Memory<byte> Data => _data;

    public partial ushort SourcePort
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (ushort)(BinaryPrimitives.ReadUInt16BigEndian(s.Slice(0)) & 0xFFFF);
            }
            int ep = 0 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 15) - bi * 8;
            int sh = 32 - 1 - endInWindow;
            return (ushort)((BinaryPrimitives.ReadUInt32BigEndian(s.Slice(bi)) >> sh) & 0xFFFFU);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                var slice = s.Slice(0);
                ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                raw = (ushort)((raw & 0x0000) | ((ushort)value & 0xFFFF));
                BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
            }
            else
            {
                int ep = 0 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 15) - bi * 8;
                int sh = 32 - 1 - endInWindow;
                var slice = s.Slice(bi);
                uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                uint m = (uint)(0xFFFFU << sh);
                raw = (uint)((raw & (uint)~m) | (((uint)value << sh) & m));
                BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
            }
        }
    }

    public partial ushort DestinationPort
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (ushort)(BinaryPrimitives.ReadUInt16BigEndian(s.Slice(2)) & 0xFFFF);
            }
            int ep = 16 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 15) - bi * 8;
            int sh = 32 - 1 - endInWindow;
            return (ushort)((BinaryPrimitives.ReadUInt32BigEndian(s.Slice(bi)) >> sh) & 0xFFFFU);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                var slice = s.Slice(2);
                ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                raw = (ushort)((raw & 0x0000) | ((ushort)value & 0xFFFF));
                BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
            }
            else
            {
                int ep = 16 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 15) - bi * 8;
                int sh = 32 - 1 - endInWindow;
                var slice = s.Slice(bi);
                uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                uint m = (uint)(0xFFFFU << sh);
                raw = (uint)((raw & (uint)~m) | (((uint)value << sh) & m));
                BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
            }
        }
    }

    public partial uint SequenceNumber
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (uint)(BinaryPrimitives.ReadUInt32BigEndian(s.Slice(4)) & 0xFFFFFFFFU);
            }
            int ep = 32 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 31) - bi * 8;
            int sh = 64 - 1 - endInWindow;
            return (uint)((BinaryPrimitives.ReadUInt64BigEndian(s.Slice(bi)) >> sh) & 0xFFFFFFFFUL);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                var slice = s.Slice(4);
                uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                raw = (uint)((raw & 0x0U) | ((uint)value & 0xFFFFFFFFU));
                BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
            }
            else
            {
                int ep = 32 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 31) - bi * 8;
                int sh = 64 - 1 - endInWindow;
                var slice = s.Slice(bi);
                ulong raw = BinaryPrimitives.ReadUInt64BigEndian(slice);
                ulong m = (ulong)(0xFFFFFFFFUL << sh);
                raw = (ulong)((raw & (ulong)~m) | (((ulong)value << sh) & m));
                BinaryPrimitives.WriteUInt64BigEndian(slice, raw);
            }
        }
    }

    public partial uint AcknowledgmentNumber
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (uint)(BinaryPrimitives.ReadUInt32BigEndian(s.Slice(8)) & 0xFFFFFFFFU);
            }
            int ep = 64 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 31) - bi * 8;
            int sh = 64 - 1 - endInWindow;
            return (uint)((BinaryPrimitives.ReadUInt64BigEndian(s.Slice(bi)) >> sh) & 0xFFFFFFFFUL);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                var slice = s.Slice(8);
                uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                raw = (uint)((raw & 0x0U) | ((uint)value & 0xFFFFFFFFU));
                BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
            }
            else
            {
                int ep = 64 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 31) - bi * 8;
                int sh = 64 - 1 - endInWindow;
                var slice = s.Slice(bi);
                ulong raw = BinaryPrimitives.ReadUInt64BigEndian(slice);
                ulong m = (ulong)(0xFFFFFFFFUL << sh);
                raw = (ulong)((raw & (ulong)~m) | (((ulong)value << sh) & m));
                BinaryPrimitives.WriteUInt64BigEndian(slice, raw);
            }
        }
    }

    public partial byte DataOffset
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (byte)((s[12] >> 4) & 0x0F);
            }
            int ep = 96 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 3) - bi * 8;
            int sh = 16 - 1 - endInWindow;
            return (byte)((BinaryPrimitives.ReadUInt16BigEndian(s.Slice(bi)) >> sh) & 0x000F);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[12] = (byte)((s[12] & 0x0F) | (((byte)value << 4) & 0xF0));
            }
            else
            {
                int ep = 96 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 3) - bi * 8;
                int sh = 16 - 1 - endInWindow;
                var slice = s.Slice(bi);
                ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                ushort m = (ushort)(0x000F << sh);
                raw = (ushort)((raw & (ushort)~m) | (((ushort)value << sh) & m));
                BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
            }
        }
    }

    public partial byte Reserved
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (byte)((s[12] >> 1) & 0x07);
            }
            int ep = 100 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 2) - bi * 8;
            int sh = 16 - 1 - endInWindow;
            return (byte)((BinaryPrimitives.ReadUInt16BigEndian(s.Slice(bi)) >> sh) & 0x0007);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[12] = (byte)((s[12] & 0xF1) | (((byte)value << 1) & 0x0E));
            }
            else
            {
                int ep = 100 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 2) - bi * 8;
                int sh = 16 - 1 - endInWindow;
                var slice = s.Slice(bi);
                ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                ushort m = (ushort)(0x0007 << sh);
                raw = (ushort)((raw & (ushort)~m) | (((ushort)value << sh) & m));
                BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
            }
        }
    }

    public partial ushort WindowSize
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (ushort)(BinaryPrimitives.ReadUInt16BigEndian(s.Slice(14)) & 0xFFFF);
            }
            int ep = 112 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 15) - bi * 8;
            int sh = 32 - 1 - endInWindow;
            return (ushort)((BinaryPrimitives.ReadUInt32BigEndian(s.Slice(bi)) >> sh) & 0xFFFFU);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                var slice = s.Slice(14);
                ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                raw = (ushort)((raw & 0x0000) | ((ushort)value & 0xFFFF));
                BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
            }
            else
            {
                int ep = 112 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 15) - bi * 8;
                int sh = 32 - 1 - endInWindow;
                var slice = s.Slice(bi);
                uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                uint m = (uint)(0xFFFFU << sh);
                raw = (uint)((raw & (uint)~m) | (((uint)value << sh) & m));
                BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
            }
        }
    }

    public partial ushort Checksum
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (ushort)(BinaryPrimitives.ReadUInt16BigEndian(s.Slice(16)) & 0xFFFF);
            }
            int ep = 128 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 15) - bi * 8;
            int sh = 32 - 1 - endInWindow;
            return (ushort)((BinaryPrimitives.ReadUInt32BigEndian(s.Slice(bi)) >> sh) & 0xFFFFU);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                var slice = s.Slice(16);
                ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                raw = (ushort)((raw & 0x0000) | ((ushort)value & 0xFFFF));
                BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
            }
            else
            {
                int ep = 128 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 15) - bi * 8;
                int sh = 32 - 1 - endInWindow;
                var slice = s.Slice(bi);
                uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                uint m = (uint)(0xFFFFU << sh);
                raw = (uint)((raw & (uint)~m) | (((uint)value << sh) & m));
                BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
            }
        }
    }

    public partial ushort UrgentPointer
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                return (ushort)(BinaryPrimitives.ReadUInt16BigEndian(s.Slice(18)) & 0xFFFF);
            }
            int ep = 144 + _bitOffset;
            int bi = ep >> 3;
            int endInWindow = (ep + 15) - bi * 8;
            int sh = 32 - 1 - endInWindow;
            return (ushort)((BinaryPrimitives.ReadUInt32BigEndian(s.Slice(bi)) >> sh) & 0xFFFFU);
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                var slice = s.Slice(18);
                ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                raw = (ushort)((raw & 0x0000) | ((ushort)value & 0xFFFF));
                BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
            }
            else
            {
                int ep = 144 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 15) - bi * 8;
                int sh = 32 - 1 - endInWindow;
                var slice = s.Slice(bi);
                uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                uint m = (uint)(0xFFFFU << sh);
                raw = (uint)((raw & (uint)~m) | (((uint)value << sh) & m));
                BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
            }
        }
    }

    public partial bool NS
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[12] & 0x01) != 0;
            int ep = 103 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[12] = value ? (byte)(s[12] | 0x01) : (byte)(s[12] & 0xFE);
                return;
            }
            int ep = 103 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    public partial bool CWR
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[13] & 0x80) != 0;
            int ep = 104 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[13] = value ? (byte)(s[13] | 0x80) : (byte)(s[13] & 0x7F);
                return;
            }
            int ep = 104 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    public partial bool ECE
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[13] & 0x40) != 0;
            int ep = 105 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[13] = value ? (byte)(s[13] | 0x40) : (byte)(s[13] & 0xBF);
                return;
            }
            int ep = 105 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    public partial bool URG
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[13] & 0x20) != 0;
            int ep = 106 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[13] = value ? (byte)(s[13] | 0x20) : (byte)(s[13] & 0xDF);
                return;
            }
            int ep = 106 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    public partial bool ACK
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[13] & 0x10) != 0;
            int ep = 107 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[13] = value ? (byte)(s[13] | 0x10) : (byte)(s[13] & 0xEF);
                return;
            }
            int ep = 107 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    public partial bool PSH
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[13] & 0x08) != 0;
            int ep = 108 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[13] = value ? (byte)(s[13] | 0x08) : (byte)(s[13] & 0xF7);
                return;
            }
            int ep = 108 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    public partial bool RST
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[13] & 0x04) != 0;
            int ep = 109 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[13] = value ? (byte)(s[13] | 0x04) : (byte)(s[13] & 0xFB);
                return;
            }
            int ep = 109 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    public partial bool SYN
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[13] & 0x02) != 0;
            int ep = 110 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[13] = value ? (byte)(s[13] | 0x02) : (byte)(s[13] & 0xFD);
                return;
            }
            int ep = 110 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    public partial bool FIN
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var s = _data.Span;
            if (_bitOffset == 0) return (s[13] & 0x01) != 0;
            int ep = 111 + _bitOffset;
            return (s[ep >> 3] & (1 << (7 - (ep & 7)))) != 0;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set
        {
            var s = _data.Span;
            if (_bitOffset == 0)
            {
                s[13] = value ? (byte)(s[13] | 0x01) : (byte)(s[13] & 0xFE);
                return;
            }
            int ep = 111 + _bitOffset;
            int bi = ep >> 3;
            int m = 1 << (7 - (ep & 7));
            s[bi] = value ? (byte)(s[bi] | m) : (byte)(s[bi] & ~m);
        }
    }

    /// <summary>Metadata for every field and flag declared on this view, in declaration order.</summary>
    public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]
    {
        new("SourcePort", 0, 16, "ushort", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("DestinationPort", 16, 16, "ushort", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("SequenceNumber", 32, 32, "uint", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("AcknowledgmentNumber", 64, 32, "uint", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("DataOffset", 96, 4, "byte", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("Reserved", 100, 3, "byte", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("WindowSize", 112, 16, "ushort", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("Checksum", 128, 16, "ushort", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("UrgentPointer", 144, 16, "ushort", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("NS", 103, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("CWR", 104, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("ECE", 105, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("URG", 106, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("ACK", 107, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("PSH", 108, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("RST", 109, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("SYN", 110, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
        new("FIN", 111, 1, "bool", true, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb),
    };

}
