// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
using System;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using Stardust.Utilities;

namespace Stardust.Utilities.Tests;

public partial class BitFieldsViewTests
{
    public partial record struct ExplicitSameEndianBeView
    {
        private readonly Memory<byte> _data;
        private readonly byte _bitOffset;

        /// <summary>Minimum number of bytes required in the backing buffer.</summary>
        public const int SizeInBytes = 28;

        /// <summary>Creates a view over the specified memory buffer.</summary>
        /// <param name="data">The buffer to view. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The buffer is too short.</exception>
        public ExplicitSameEndianBeView(Memory<byte> data)
        {
            if (data.Length < SizeInBytes)
                throw new ArgumentException($"Buffer must contain at least {SizeInBytes} bytes, but was {data.Length}.", nameof(data));
            _data = data;
            _bitOffset = 0;
        }

        /// <summary>Creates a view over the specified byte array.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ExplicitSameEndianBeView(byte[] data) : this(data.AsMemory()) { }

        /// <summary>Creates a view over a portion of the specified byte array.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ExplicitSameEndianBeView(byte[] data, int offset) : this(data.AsMemory(offset)) { }

        /// <summary>Creates a sub-view at a bit offset within the specified memory buffer (used by nested views).</summary>
        internal ExplicitSameEndianBeView(Memory<byte> data, int bitOffset)
        {
            _data = data;
            _bitOffset = (byte)bitOffset;
        }

        /// <summary>Gets the underlying memory buffer.</summary>
        public Memory<byte> Data => _data;

        public partial global::Stardust.Utilities.UInt16Be U16
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (global::Stardust.Utilities.UInt16Be)(ushort)(BinaryPrimitives.ReadUInt16BigEndian(s.Slice(0)) & 0xFFFF);
                }
                int ep = 0 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 15) - bi * 8;
                int sh = 32 - 1 - endInWindow;
                return (global::Stardust.Utilities.UInt16Be)(ushort)((BinaryPrimitives.ReadUInt32BigEndian(s.Slice(bi)) >> sh) & 0xFFFFU);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    var slice = s.Slice(0);
                    ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                    raw = (ushort)((raw & 0x0000) | ((ushort)(ushort)value & 0xFFFF));
                    BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
                }
                else
                {
                    int ep = 0 + _bitOffset;
                    int bi = ep >> 3;
                    int endInWindow = (ep + 15) - bi * 8;
                    int sh = 32 - 1 - endInWindow;
                    var slice = s.Slice(bi);
                    uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                    uint m = (uint)(0xFFFFU << sh);
                    raw = (uint)((raw & (uint)~m) | (((uint)(ushort)value << sh) & m));
                    BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
                }
            }
        }

        public partial global::Stardust.Utilities.Int16Be S16
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (global::Stardust.Utilities.Int16Be)(short)(BinaryPrimitives.ReadUInt16BigEndian(s.Slice(2)) & 0xFFFF);
                }
                int ep = 16 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 15) - bi * 8;
                int sh = 32 - 1 - endInWindow;
                return (global::Stardust.Utilities.Int16Be)(short)((BinaryPrimitives.ReadUInt32BigEndian(s.Slice(bi)) >> sh) & 0xFFFFU);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    var slice = s.Slice(2);
                    ushort raw = BinaryPrimitives.ReadUInt16BigEndian(slice);
                    raw = (ushort)((raw & 0x0000) | ((ushort)(short)value & 0xFFFF));
                    BinaryPrimitives.WriteUInt16BigEndian(slice, raw);
                }
                else
                {
                    int ep = 16 + _bitOffset;
                    int bi = ep >> 3;
                    int endInWindow = (ep + 15) - bi * 8;
                    int sh = 32 - 1 - endInWindow;
                    var slice = s.Slice(bi);
                    uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                    uint m = (uint)(0xFFFFU << sh);
                    raw = (uint)((raw & (uint)~m) | (((uint)(short)value << sh) & m));
                    BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
                }
            }
        }

        public partial global::Stardust.Utilities.UInt32Be U32
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (global::Stardust.Utilities.UInt32Be)(uint)(BinaryPrimitives.ReadUInt32BigEndian(s.Slice(4)) & 0xFFFFFFFFU);
                }
                int ep = 32 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 31) - bi * 8;
                int sh = 64 - 1 - endInWindow;
                return (global::Stardust.Utilities.UInt32Be)(uint)((BinaryPrimitives.ReadUInt64BigEndian(s.Slice(bi)) >> sh) & 0xFFFFFFFFUL);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    var slice = s.Slice(4);
                    uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                    raw = (uint)((raw & 0x0U) | ((uint)(uint)value & 0xFFFFFFFFU));
                    BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
                }
                else
                {
                    int ep = 32 + _bitOffset;
                    int bi = ep >> 3;
                    int endInWindow = (ep + 31) - bi * 8;
                    int sh = 64 - 1 - endInWindow;
                    var slice = s.Slice(bi);
                    ulong raw = BinaryPrimitives.ReadUInt64BigEndian(slice);
                    ulong m = (ulong)(0xFFFFFFFFUL << sh);
                    raw = (ulong)((raw & (ulong)~m) | (((ulong)(uint)value << sh) & m));
                    BinaryPrimitives.WriteUInt64BigEndian(slice, raw);
                }
            }
        }

        public partial global::Stardust.Utilities.Int32Be S32
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (global::Stardust.Utilities.Int32Be)(int)(BinaryPrimitives.ReadUInt32BigEndian(s.Slice(8)) & 0xFFFFFFFFU);
                }
                int ep = 64 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 31) - bi * 8;
                int sh = 64 - 1 - endInWindow;
                return (global::Stardust.Utilities.Int32Be)(int)((BinaryPrimitives.ReadUInt64BigEndian(s.Slice(bi)) >> sh) & 0xFFFFFFFFUL);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    var slice = s.Slice(8);
                    uint raw = BinaryPrimitives.ReadUInt32BigEndian(slice);
                    raw = (uint)((raw & 0x0U) | ((uint)(int)value & 0xFFFFFFFFU));
                    BinaryPrimitives.WriteUInt32BigEndian(slice, raw);
                }
                else
                {
                    int ep = 64 + _bitOffset;
                    int bi = ep >> 3;
                    int endInWindow = (ep + 31) - bi * 8;
                    int sh = 64 - 1 - endInWindow;
                    var slice = s.Slice(bi);
                    ulong raw = BinaryPrimitives.ReadUInt64BigEndian(slice);
                    ulong m = (ulong)(0xFFFFFFFFUL << sh);
                    raw = (ulong)((raw & (ulong)~m) | (((ulong)(int)value << sh) & m));
                    BinaryPrimitives.WriteUInt64BigEndian(slice, raw);
                }
            }
        }

        public partial global::Stardust.Utilities.UInt64Be U64
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (global::Stardust.Utilities.UInt64Be)(ulong)(BinaryPrimitives.ReadUInt64BigEndian(s.Slice(12)) & 0xFFFFFFFFFFFFFFFFUL);
                }
                int ep = 96 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 63) - bi * 8;
                int sh = 64 - 1 - endInWindow;
                return (global::Stardust.Utilities.UInt64Be)(ulong)((BinaryPrimitives.ReadUInt64BigEndian(s.Slice(bi)) >> sh) & 0xFFFFFFFFFFFFFFFFUL);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    var slice = s.Slice(12);
                    ulong raw = BinaryPrimitives.ReadUInt64BigEndian(slice);
                    raw = (ulong)((raw & 0x0UL) | ((ulong)(ulong)value & 0xFFFFFFFFFFFFFFFFUL));
                    BinaryPrimitives.WriteUInt64BigEndian(slice, raw);
                }
                else
                {
                    int ep = 96 + _bitOffset;
                    int bi = ep >> 3;
                    int endInWindow = (ep + 63) - bi * 8;
                    int sh = 64 - 1 - endInWindow;
                    var slice = s.Slice(bi);
                    ulong raw = BinaryPrimitives.ReadUInt64BigEndian(slice);
                    ulong m = (ulong)(0xFFFFFFFFFFFFFFFFUL << sh);
                    raw = (ulong)((raw & (ulong)~m) | (((ulong)(ulong)value << sh) & m));
                    BinaryPrimitives.WriteUInt64BigEndian(slice, raw);
                }
            }
        }

        public partial global::Stardust.Utilities.Int64Be S64
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (global::Stardust.Utilities.Int64Be)(long)(BinaryPrimitives.ReadUInt64BigEndian(s.Slice(20)) & 0xFFFFFFFFFFFFFFFFUL);
                }
                int ep = 160 + _bitOffset;
                int bi = ep >> 3;
                int endInWindow = (ep + 63) - bi * 8;
                int sh = 64 - 1 - endInWindow;
                return (global::Stardust.Utilities.Int64Be)(long)((BinaryPrimitives.ReadUInt64BigEndian(s.Slice(bi)) >> sh) & 0xFFFFFFFFFFFFFFFFUL);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    var slice = s.Slice(20);
                    ulong raw = BinaryPrimitives.ReadUInt64BigEndian(slice);
                    raw = (ulong)((raw & 0x0UL) | ((ulong)(long)value & 0xFFFFFFFFFFFFFFFFUL));
                    BinaryPrimitives.WriteUInt64BigEndian(slice, raw);
                }
                else
                {
                    int ep = 160 + _bitOffset;
                    int bi = ep >> 3;
                    int endInWindow = (ep + 63) - bi * 8;
                    int sh = 64 - 1 - endInWindow;
                    var slice = s.Slice(bi);
                    ulong raw = BinaryPrimitives.ReadUInt64BigEndian(slice);
                    ulong m = (ulong)(0xFFFFFFFFFFFFFFFFUL << sh);
                    raw = (ulong)((raw & (ulong)~m) | (((ulong)(long)value << sh) & m));
                    BinaryPrimitives.WriteUInt64BigEndian(slice, raw);
                }
            }
        }

        /// <summary>Metadata for every field and flag declared on this view, in declaration order.</summary>
        public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]
        {
            new("U16", 0, 16, "Stardust.Utilities.UInt16Be", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb, StructTotalBits: 224, FieldMustBe: 0),
            new("S16", 16, 16, "Stardust.Utilities.Int16Be", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb, StructTotalBits: 224, FieldMustBe: 0),
            new("U32", 32, 32, "Stardust.Utilities.UInt32Be", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb, StructTotalBits: 224, FieldMustBe: 0),
            new("S32", 64, 32, "Stardust.Utilities.Int32Be", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb, StructTotalBits: 224, FieldMustBe: 0),
            new("U64", 96, 64, "Stardust.Utilities.UInt64Be", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb, StructTotalBits: 224, FieldMustBe: 0),
            new("S64", 160, 64, "Stardust.Utilities.Int64Be", false, ByteOrder.BigEndian, BitOrder.BitZeroIsMsb, StructTotalBits: 224, FieldMustBe: 0),
        };

    }
}
