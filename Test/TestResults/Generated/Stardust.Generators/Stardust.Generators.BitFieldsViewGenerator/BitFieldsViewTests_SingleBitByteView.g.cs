// <auto-generated>
// This code was generated by Stardust.Generators source generator.
// </auto-generated>
#nullable enable
using System;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;
using Stardust.Utilities;

namespace Stardust.Utilities.Tests;

public partial class BitFieldsViewTests
{
    public partial record struct SingleBitByteView
    {
        private readonly Memory<byte> _data;
        private readonly byte _bitOffset;

        /// <summary>Minimum number of bytes required in the backing buffer.</summary>
        public const int SizeInBytes = 1;

        /// <summary>Creates a view over the specified memory buffer.</summary>
        /// <param name="data">The buffer to view. Must contain at least <see cref="SizeInBytes"/> bytes.</param>
        /// <exception cref="ArgumentException">The buffer is too short.</exception>
        public SingleBitByteView(Memory<byte> data)
        {
            if (data.Length < SizeInBytes)
                throw new ArgumentException($"Buffer must contain at least {SizeInBytes} bytes, but was {data.Length}.", nameof(data));
            _data = data;
            _bitOffset = 0;
        }

        /// <summary>Creates a view over the specified byte array.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SingleBitByteView(byte[] data) : this(data.AsMemory()) { }

        /// <summary>Creates a view over a portion of the specified byte array.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SingleBitByteView(byte[] data, int offset) : this(data.AsMemory(offset)) { }

        /// <summary>Creates a sub-view at a bit offset within the specified memory buffer (used by nested views).</summary>
        internal SingleBitByteView(Memory<byte> data, int bitOffset)
        {
            _data = data;
            _bitOffset = (byte)bitOffset;
        }

        /// <summary>Gets the underlying memory buffer.</summary>
        public Memory<byte> Data => _data;

        public partial byte Bit0
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (byte)(s[0] & 0x01);
                }
                int ep = 0 + _bitOffset;
                int bi = ep >> 3;
                int sh = ep & 7;
                return (byte)((s[bi] >> sh) & 0x01);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    s[0] = (byte)((s[0] & 0xFE) | ((byte)value & 0x01));
                }
                else
                {
                    int ep = 0 + _bitOffset;
                    int bi = ep >> 3;
                    int sh = ep & 7;
                    int m = 0x01 << sh;
                    s[bi] = (byte)((s[bi] & ~m) | (((int)value << sh) & m));
                }
            }
        }

        public partial byte Bit1
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (byte)((s[0] >> 1) & 0x01);
                }
                int ep = 1 + _bitOffset;
                int bi = ep >> 3;
                int sh = ep & 7;
                return (byte)((s[bi] >> sh) & 0x01);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    s[0] = (byte)((s[0] & 0xFD) | (((byte)value << 1) & 0x02));
                }
                else
                {
                    int ep = 1 + _bitOffset;
                    int bi = ep >> 3;
                    int sh = ep & 7;
                    int m = 0x01 << sh;
                    s[bi] = (byte)((s[bi] & ~m) | (((int)value << sh) & m));
                }
            }
        }

        public partial byte Rest
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    return (byte)((s[0] >> 2) & 0x3F);
                }
                int ep = 2 + _bitOffset;
                int bi = ep >> 3;
                int sh = ep & 7;
                return (byte)((BinaryPrimitives.ReadUInt16LittleEndian(s.Slice(bi)) >> sh) & 0x003F);
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                var s = _data.Span;
                if (_bitOffset == 0)
                {
                    s[0] = (byte)((s[0] & 0x03) | (((byte)value << 2) & 0xFC));
                }
                else
                {
                    int ep = 2 + _bitOffset;
                    int bi = ep >> 3;
                    int sh = ep & 7;
                    var slice = s.Slice(bi);
                    ushort raw = BinaryPrimitives.ReadUInt16LittleEndian(slice);
                    ushort m = (ushort)(0x003F << sh);
                    raw = (ushort)((raw & (ushort)~m) | (((ushort)value << sh) & m));
                    BinaryPrimitives.WriteUInt16LittleEndian(slice, raw);
                }
            }
        }

        /// <summary>Metadata for every field and flag declared on this view, in declaration order.</summary>
        public static ReadOnlySpan<BitFieldInfo> Fields => new BitFieldInfo[]
        {
            new("Bit0", 0, 1, "byte", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 8, FieldMustBe: 0),
            new("Bit1", 1, 1, "byte", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 8, FieldMustBe: 0),
            new("Rest", 2, 6, "byte", false, ByteOrder.LittleEndian, BitOrder.BitZeroIsLsb, StructTotalBits: 8, FieldMustBe: 0),
        };

    }
}
