using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Stardust.Utilities.Tool;

/// <summary>
/// Code generation tool for Stardust.Utilities.
/// Generates .Designer.cs files for [EnhancedEnum] and [BitFields] attributed types.
/// </summary>
class Program
{
    static int Main(string[] args)
    {
        if (args.Length == 0)
        {
            Console.Error.WriteLine("Usage: stardust-codegen <directory> [--verbose]");
            Console.Error.WriteLine("  Scans directory recursively for .cs files with [EnhancedEnum] or [BitFields]");
            Console.Error.WriteLine("  and generates corresponding .Designer.cs files.");
            return 1;
        }

        var directory = args[0];
        var verbose = args.Contains("--verbose");

        if (!Directory.Exists(directory))
        {
            Console.Error.WriteLine($"Directory not found: {directory}");
            return 1;
        }

        var generator = new CodeGenerator(verbose);
        var count = generator.ProcessDirectory(directory);

        if (verbose)
            Console.WriteLine($"Processed {count} file(s).");

        return 0;
    }
}

/// <summary>
/// Processes C# source files and generates .Designer.cs files.
/// </summary>
class CodeGenerator
{
    private readonly bool _verbose;

    public CodeGenerator(bool verbose)
    {
        _verbose = verbose;
    }

    public int ProcessDirectory(string directory)
    {
        int count = 0;
        var csFiles = Directory.GetFiles(directory, "*.cs", SearchOption.AllDirectories)
            .Where(f => !f.EndsWith(".Designer.cs") && !f.EndsWith(".Generated.cs") && !f.EndsWith(".g.cs"))
            .Where(f => !f.Contains($"{Path.DirectorySeparatorChar}obj{Path.DirectorySeparatorChar}"))
            .Where(f => !f.Contains($"{Path.DirectorySeparatorChar}bin{Path.DirectorySeparatorChar}"));

        foreach (var file in csFiles)
        {
            if (ProcessFile(file))
                count++;
        }

        return count;
    }

    private bool ProcessFile(string filePath)
    {
        var source = File.ReadAllText(filePath);
        var tree = CSharpSyntaxTree.ParseText(source);
        var root = tree.GetCompilationUnitRoot();

        var enhancedEnums = new List<EnhancedEnumInfo>();
        var bitFields = new List<BitFieldsInfo>();

        // Find all structs with attributes
        foreach (var structDecl in root.DescendantNodes().OfType<StructDeclarationSyntax>())
        {
            var hasEnhancedEnum = structDecl.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(a => a.Name.ToString() is "EnhancedEnum" or "EnhancedEnumAttribute");

            var hasBitFields = structDecl.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(a => a.Name.ToString() is "BitFields" or "BitFieldsAttribute");

            if (hasEnhancedEnum)
            {
                var info = ExtractEnhancedEnumInfo(structDecl, root);
                if (info != null)
                    enhancedEnums.Add(info);
            }

            if (hasBitFields)
            {
                var info = ExtractBitFieldsInfo(structDecl, root);
                if (info != null)
                    bitFields.Add(info);
            }
        }

        if (enhancedEnums.Count == 0 && bitFields.Count == 0)
            return false;

        // Generate single .Generated.cs file for all types in this source file
        var generatedPath = Path.ChangeExtension(filePath, ".Generated.cs");
        var code = GenerateFile(enhancedEnums, bitFields);

        return WriteIfChanged(generatedPath, code);
    }

    private bool WriteIfChanged(string path, string code)
    {
        if (File.Exists(path))
        {
            var existing = File.ReadAllText(path);
            if (existing == code)
            {
                if (_verbose)
                    Console.WriteLine($"Unchanged: {path}");
                return false;
            }
        }

        File.WriteAllText(path, code);
        if (_verbose)
            Console.WriteLine($"Generated: {path}");
        return true;
    }

    private string GenerateFile(List<EnhancedEnumInfo> enhancedEnums, List<BitFieldsInfo> bitFields)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("// This code was generated by Stardust.Utilities.Tool.");
        sb.AppendLine("// Changes to code inside #region blocks will be overwritten.");
        sb.AppendLine("// Add custom code outside the #region blocks.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();

        // Get namespace from first type
        string? ns = null;
        if (enhancedEnums.Count > 0)
            ns = enhancedEnums[0].Namespace;
        else if (bitFields.Count > 0)
            ns = bitFields[0].Namespace;

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine($"namespace {ns};");
            sb.AppendLine();
        }

        // Generate EnhancedEnum implementations
        foreach (var info in enhancedEnums)
        {
            GenerateEnhancedEnum(sb, info);
            sb.AppendLine();
        }

        // Generate BitFields implementations
        foreach (var info in bitFields)
        {
            GenerateBitFields(sb, info);
            sb.AppendLine();
        }

        return sb.ToString();
    }

    #region EnhancedEnum Generation

    private EnhancedEnumInfo? ExtractEnhancedEnumInfo(StructDeclarationSyntax structDecl, CompilationUnitSyntax root)
    {
        var structName = structDecl.Identifier.Text;
        var accessibility = GetAccessibility(structDecl.Modifiers);

        // Find namespace
        string? ns = null;
        var nsDecl = structDecl.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
        if (nsDecl != null)
            ns = nsDecl.Name.ToString();

        // Find the Kind enum with [EnumKind] attribute
        var kindEnum = structDecl.Members
            .OfType<EnumDeclarationSyntax>()
            .FirstOrDefault(e => e.AttributeLists
                .SelectMany(al => al.Attributes)
                .Any(a => a.Name.ToString() is "EnumKind" or "EnumKindAttribute"));

        if (kindEnum == null)
            return null;

        var variants = new List<VariantInfo>();

        foreach (var member in kindEnum.Members)
        {
            var enumValueAttr = member.AttributeLists
                .SelectMany(al => al.Attributes)
                .FirstOrDefault(a => a.Name.ToString() is "EnumValue" or "EnumValueAttribute");

            string? payloadType = null;
            bool isReferenceType = false;

            if (enumValueAttr?.ArgumentList?.Arguments.Count > 0)
            {
                var arg = enumValueAttr.ArgumentList.Arguments[0];
                if (arg.Expression is TypeOfExpressionSyntax typeOf)
                {
                    payloadType = typeOf.Type.ToString();
                    // Reference types: string, classes (start with uppercase, not tuple, not primitive)
                    isReferenceType = payloadType == "string" ||
                                     (!payloadType.StartsWith("(") &&
                                      !IsPrimitiveType(payloadType) &&
                                      char.IsUpper(payloadType[0]));
                }
            }

            variants.Add(new VariantInfo(member.Identifier.Text, payloadType, isReferenceType));
        }

        return new EnhancedEnumInfo(structName, ns, accessibility, variants);
    }

    private bool IsPrimitiveType(string typeName) =>
        typeName is "byte" or "sbyte" or "short" or "ushort" or "int" or "uint" or
                   "long" or "ulong" or "float" or "double" or "decimal" or "bool" or "char";

    private void GenerateEnhancedEnum(StringBuilder sb, EnhancedEnumInfo info)
    {
        var variantsWithPayload = info.Variants.Where(v => v.PayloadType != null).ToList();

        sb.AppendLine($"{info.Accessibility} readonly partial struct {info.TypeName} : IEquatable<{info.TypeName}>");
        sb.AppendLine("{");
        sb.AppendLine("    #region Generated Code - Do Not Modify");
        sb.AppendLine();

        // Fields
        sb.AppendLine("    private readonly Kind _tag;");
        foreach (var v in variantsWithPayload)
        {
            var fieldName = $"_{ToCamelCase(v.Name)}Payload";
            var nullableSuffix = v.IsReferenceType ? "?" : "";
            sb.AppendLine($"    private readonly {v.PayloadType}{nullableSuffix} {fieldName};");
        }
        sb.AppendLine();

        // Tag property
        sb.AppendLine("    /// <summary>Gets the discriminant tag indicating which variant this is.</summary>");
        sb.AppendLine("    public Kind Tag => _tag;");
        sb.AppendLine();

        // Private constructor
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.Append($"    private {info.TypeName}(Kind tag");
        foreach (var v in variantsWithPayload)
        {
            var nullableSuffix = v.IsReferenceType ? "?" : "";
            sb.Append($", {v.PayloadType}{nullableSuffix} {ToCamelCase(v.Name)}Payload");
        }
        sb.AppendLine(")");
        sb.AppendLine("    {");
        sb.AppendLine("        _tag = tag;");
        foreach (var v in variantsWithPayload)
        {
            var fieldName = $"_{ToCamelCase(v.Name)}Payload";
            sb.AppendLine($"        {fieldName} = {ToCamelCase(v.Name)}Payload;");
        }
        sb.AppendLine("    }");
        sb.AppendLine();

        // Factory methods
        foreach (var v in info.Variants)
        {
            sb.AppendLine($"    /// <summary>Creates a {v.Name} variant.</summary>");
            if (v.PayloadType != null)
            {
                sb.AppendLine($"    /// <param name=\"value\">The payload value.</param>");
                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append($"    public static {info.TypeName} {v.Name}({v.PayloadType} value) => new(Kind.{v.Name}");
            }
            else
            {
                sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
                sb.Append($"    public static {info.TypeName} {v.Name}() => new(Kind.{v.Name}");
            }
            foreach (var vp in variantsWithPayload)
            {
                if (vp.Name == v.Name)
                    sb.Append(", value");
                else
                    sb.Append(", default");
            }
            sb.AppendLine(");");
            sb.AppendLine();
        }

        // Is properties
        foreach (var v in info.Variants)
        {
            sb.AppendLine($"    /// <summary>Returns true if this is the {v.Name} variant.</summary>");
            sb.AppendLine($"    public bool Is{v.Name} => _tag == Kind.{v.Name};");
            sb.AppendLine();
        }

        // TryGet methods
        foreach (var v in variantsWithPayload)
        {
            var fieldName = $"_{ToCamelCase(v.Name)}Payload";
            sb.AppendLine($"    /// <summary>Attempts to get the {v.Name} payload.</summary>");
            sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"    public bool TryGet{v.Name}(out {v.PayloadType} value)");
            sb.AppendLine("    {");
            sb.AppendLine($"        if (_tag == Kind.{v.Name})");
            sb.AppendLine("        {");
            if (v.IsReferenceType)
                sb.AppendLine($"            value = {fieldName}!;");
            else
                sb.AppendLine($"            value = {fieldName};");
            sb.AppendLine("            return true;");
            sb.AppendLine("        }");
            sb.AppendLine("        value = default!;");
            sb.AppendLine("        return false;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // Match method (Func version)
        GenerateMatchMethod(sb, info, variantsWithPayload);

        // Match method (Action version)
        GenerateMatchMethodVoid(sb, info, variantsWithPayload);

        // Equality
        GenerateEquality(sb, info, variantsWithPayload);

        sb.AppendLine("    #endregion");
        sb.AppendLine("}");
    }

    private void GenerateMatchMethod(StringBuilder sb, EnhancedEnumInfo info, List<VariantInfo> variantsWithPayload)
    {
        sb.AppendLine("    /// <summary>Exhaustively matches all variants and returns a result.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public TResult Match<TResult>(");
        for (int i = 0; i < info.Variants.Count; i++)
        {
            var v = info.Variants[i];
            var paramName = ToSafeParameterName(v.Name);
            var comma = i < info.Variants.Count - 1 ? "," : ")";
            if (v.PayloadType != null)
                sb.AppendLine($"        Func<{v.PayloadType}, TResult> {paramName}{comma}");
            else
                sb.AppendLine($"        Func<TResult> {paramName}{comma}");
        }
        sb.AppendLine("    {");
        sb.AppendLine("        return _tag switch");
        sb.AppendLine("        {");
        foreach (var v in info.Variants)
        {
            var paramName = ToSafeParameterName(v.Name);
            if (v.PayloadType != null)
            {
                var fieldName = $"_{ToCamelCase(v.Name)}Payload";
                var nullForgiving = v.IsReferenceType ? "!" : "";
                sb.AppendLine($"            Kind.{v.Name} => {paramName}({fieldName}{nullForgiving}),");
            }
            else
            {
                sb.AppendLine($"            Kind.{v.Name} => {paramName}(),");
            }
        }
        sb.AppendLine("            _ => throw new InvalidOperationException($\"Unknown tag: {_tag}\")");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateMatchMethodVoid(StringBuilder sb, EnhancedEnumInfo info, List<VariantInfo> variantsWithPayload)
    {
        sb.AppendLine("    /// <summary>Exhaustively matches all variants and performs an action.</summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public void Match(");
        for (int i = 0; i < info.Variants.Count; i++)
        {
            var v = info.Variants[i];
            var paramName = ToSafeParameterName(v.Name);
            var comma = i < info.Variants.Count - 1 ? "," : ")";
            if (v.PayloadType != null)
                sb.AppendLine($"        Action<{v.PayloadType}> {paramName}{comma}");
            else
                sb.AppendLine($"        Action {paramName}{comma}");
        }
        sb.AppendLine("    {");
        sb.AppendLine("        switch (_tag)");
        sb.AppendLine("        {");
        foreach (var v in info.Variants)
        {
            var paramName = ToSafeParameterName(v.Name);
            if (v.PayloadType != null)
            {
                var fieldName = $"_{ToCamelCase(v.Name)}Payload";
                var nullForgiving = v.IsReferenceType ? "!" : "";
                sb.AppendLine($"            case Kind.{v.Name}: {paramName}({fieldName}{nullForgiving}); break;");
            }
            else
            {
                sb.AppendLine($"            case Kind.{v.Name}: {paramName}(); break;");
            }
        }
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private void GenerateEquality(StringBuilder sb, EnhancedEnumInfo info, List<VariantInfo> variantsWithPayload)
    {
        sb.AppendLine($"    /// <inheritdoc/>");
        sb.AppendLine($"    public bool Equals({info.TypeName} other)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (_tag != other._tag) return false;");
        sb.AppendLine("        return _tag switch");
        sb.AppendLine("        {");
        foreach (var v in info.Variants)
        {
            if (v.PayloadType != null)
            {
                var fieldName = $"_{ToCamelCase(v.Name)}Payload";
                sb.AppendLine($"            Kind.{v.Name} => EqualityComparer<{v.PayloadType}>.Default.Equals({fieldName}, other.{fieldName}),");
            }
            else
            {
                sb.AppendLine($"            Kind.{v.Name} => true,");
            }
        }
        sb.AppendLine("            _ => false");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine($"    public override bool Equals(object? obj) => obj is {info.TypeName} other && Equals(other);");
        sb.AppendLine();

        sb.AppendLine("    /// <inheritdoc/>");
        sb.AppendLine("    public override int GetHashCode()");
        sb.AppendLine("    {");
        sb.AppendLine("        return _tag switch");
        sb.AppendLine("        {");
        foreach (var v in info.Variants)
        {
            if (v.PayloadType != null)
            {
                var fieldName = $"_{ToCamelCase(v.Name)}Payload";
                sb.AppendLine($"            Kind.{v.Name} => HashCode.Combine(_tag, {fieldName}),");
            }
            else
            {
                sb.AppendLine($"            Kind.{v.Name} => HashCode.Combine(_tag),");
            }
        }
        sb.AppendLine("            _ => 0");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.AppendLine($"    /// <summary>Equality operator.</summary>");
        sb.AppendLine($"    public static bool operator ==({info.TypeName} left, {info.TypeName} right) => left.Equals(right);");
        sb.AppendLine();
        sb.AppendLine($"    /// <summary>Inequality operator.</summary>");
        sb.AppendLine($"    public static bool operator !=({info.TypeName} left, {info.TypeName} right) => !left.Equals(right);");
        sb.AppendLine();
    }

    #endregion

    #region BitFields Generation

    private BitFieldsInfo? ExtractBitFieldsInfo(StructDeclarationSyntax structDecl, CompilationUnitSyntax root)
    {
        var structName = structDecl.Identifier.Text;
        var accessibility = GetAccessibility(structDecl.Modifiers);

        // Find namespace
        string? ns = null;
        var nsDecl = structDecl.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
        if (nsDecl != null)
            ns = nsDecl.Name.ToString();

        // Find Value field/property and its type
        string? storageType = null;
        foreach (var member in structDecl.Members)
        {
            if (member is FieldDeclarationSyntax field)
            {
                foreach (var variable in field.Declaration.Variables)
                {
                    if (variable.Identifier.Text == "Value")
                    {
                        storageType = field.Declaration.Type.ToString();
                        break;
                    }
                }
            }
            else if (member is PropertyDeclarationSyntax prop && prop.Identifier.Text == "Value")
            {
                storageType = prop.Type.ToString();
            }
        }

        if (storageType == null)
            return null;

        var fields = new List<BitFieldInfo>();
        var flags = new List<BitFlagInfo>();

        foreach (var member in structDecl.Members.OfType<PropertyDeclarationSyntax>())
        {
            if (!member.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                continue;

            var propName = member.Identifier.Text;
            var propType = member.Type.ToString();

            foreach (var attrList in member.AttributeLists)
            {
                foreach (var attr in attrList.Attributes)
                {
                    var attrName = attr.Name.ToString();
                    if (attrName is "BitField" or "BitFieldAttribute" && attr.ArgumentList?.Arguments.Count >= 2)
                    {
                        var shift = attr.ArgumentList.Arguments[0].ToString();
                        var width = attr.ArgumentList.Arguments[1].ToString();
                        fields.Add(new BitFieldInfo(propName, propType, shift, width));
                    }
                    else if (attrName is "BitFlag" or "BitFlagAttribute" && attr.ArgumentList?.Arguments.Count >= 1)
                    {
                        var bit = attr.ArgumentList.Arguments[0].ToString();
                        flags.Add(new BitFlagInfo(propName, bit));
                    }
                }
            }
        }

        if (fields.Count == 0 && flags.Count == 0)
            return null;

        return new BitFieldsInfo(structName, ns, accessibility, storageType, fields, flags);
    }

    private void GenerateBitFields(StringBuilder sb, BitFieldsInfo info)
    {
        var defType = info.StorageType switch
        {
            "byte" => "8",
            "ushort" => "16",
            "uint" => "32",
            "ulong" => "64",
            _ => "32"
        };

        sb.AppendLine($"{info.Accessibility} partial struct {info.TypeName}");
        sb.AppendLine("{");
        sb.AppendLine("    #region Generated Code - Do Not Modify");
        sb.AppendLine();

        // Generate static field definitions
        foreach (var field in info.Fields)
        {
            sb.AppendLine($"    private static readonly Stardust.Utilities.BitFieldDef{defType} _{field.Name}Def = new({field.Shift}, {field.Width});");
        }
        foreach (var flag in info.Flags)
        {
            sb.AppendLine($"    private static readonly Stardust.Utilities.BitFlagDef{defType} _{flag.Name}Def = new({flag.Bit});");
        }
        sb.AppendLine();

        // Generate property implementations
        foreach (var field in info.Fields)
        {
            sb.AppendLine($"    public partial {field.PropertyType} {field.Name}");
            sb.AppendLine("    {");
            sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        get => _{field.Name}Def.Get{GetExtractMethod(field.PropertyType)}(Value);");
            sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        set => Value = _{field.Name}Def.Set(Value, value);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        foreach (var flag in info.Flags)
        {
            sb.AppendLine($"    public partial bool {flag.Name}");
            sb.AppendLine("    {");
            sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        get => _{flag.Name}Def.IsSet(Value);");
            sb.AppendLine($"        [MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.AppendLine($"        set => Value = _{flag.Name}Def.Set(Value, value);");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // Generate implicit conversions
        sb.AppendLine($"    public static implicit operator {info.StorageType}({info.TypeName} value) => value.Value;");
        sb.AppendLine($"    public static implicit operator {info.TypeName}({info.StorageType} value) => new() {{ Value = value }};");
        sb.AppendLine();

        sb.AppendLine("    #endregion");
        sb.AppendLine("}");
    }

    private string GetExtractMethod(string propType) => propType switch
    {
        "byte" => "Byte",
        "ushort" => "UShort",
        "uint" => "UInt",
        "ulong" => "ULong",
        _ => "Byte"
    };

    #endregion

    #region Helpers

    private string GetAccessibility(SyntaxTokenList modifiers)
    {
        if (modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword))) return "public";
        if (modifiers.Any(m => m.IsKind(SyntaxKind.InternalKeyword))) return "internal";
        if (modifiers.Any(m => m.IsKind(SyntaxKind.ProtectedKeyword))) return "protected";
        if (modifiers.Any(m => m.IsKind(SyntaxKind.PrivateKeyword))) return "private";
        return "internal";
    }

    private string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }

    private string ToSafeParameterName(string name)
    {
        var lower = name.ToLowerInvariant();
        return lower switch
        {
            "continue" or "break" or "return" or "if" or "else" or "switch" or "case" or
            "default" or "for" or "foreach" or "while" or "do" or "try" or "catch" or
            "finally" or "throw" or "new" or "this" or "base" or "null" or "true" or
            "false" or "void" or "int" or "string" or "bool" or "object" or "class" or
            "struct" or "enum" or "interface" or "delegate" or "event" or "namespace" or
            "using" or "static" or "const" or "readonly" or "volatile" or "public" or
            "private" or "protected" or "internal" or "abstract" or "virtual" or "override" or
            "sealed" or "partial" or "async" or "await" or "ref" or "out" or "in" or
            "params" or "lock" or "checked" or "unchecked" or "fixed" or "sizeof" or
            "typeof" or "is" or "as" or "goto" or "stackalloc" => $"@{name}",
            _ => name
        };
    }

    #endregion
}

#region Info Classes

record EnhancedEnumInfo(string TypeName, string? Namespace, string Accessibility, List<VariantInfo> Variants);
record VariantInfo(string Name, string? PayloadType, bool IsReferenceType);
record BitFieldsInfo(string TypeName, string? Namespace, string Accessibility, string StorageType, List<BitFieldInfo> Fields, List<BitFlagInfo> Flags);
record BitFieldInfo(string Name, string PropertyType, string Shift, string Width);
record BitFlagInfo(string Name, string Bit);

#endregion
