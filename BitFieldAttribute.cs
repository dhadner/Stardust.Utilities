namespace Stardust.Utilities;

/// <summary>
/// Marks a property as a multi-bit field spanning from startBit to endBit (inclusive).
/// </summary>
/// <remarks>
/// <para>
/// Uses Rust-style inclusive bit range syntax where the width is calculated as 
/// (endBit - startBit + 1). For example, <c>[BitField(0, 2)]</c> defines a 3-bit 
/// field spanning bits 0, 1, and 2.
/// </para>
/// <para>
/// The property must be declared as <c>public partial {type}</c> where type is
/// byte, ushort, uint, or ulong. The generator will implement the getter/setter
/// using inline bit manipulation.
/// </para>
/// <example>
/// <code>
/// [BitFields(typeof(byte))]
/// public partial struct RegisterA
/// {
///     // 3-bit field at bits 0, 1, 2 (like Rust's 0..=2)
///     [BitField(0, 2)] public partial byte Sound { get; set; }
///     
///     // Single bit at position 3 (width = 1)
///     [BitField(3, 3)] public partial byte Flag { get; set; }
///     
///     // 4-bit field at bits 4, 5, 6, 7 (like Rust's 4..=7)
///     [BitField(4, 7)] public partial byte Mode { get; set; }
/// }
/// </code>
/// </example>
/// </remarks>
[AttributeUsage(AttributeTargets.Property)]
public sealed class BitFieldAttribute : Attribute
{
    /// <summary>
    /// The starting bit position (0-based, inclusive).
    /// </summary>
    public int StartBit { get; }

    /// <summary>
    /// The ending bit position (0-based, inclusive).
    /// </summary>
    public int EndBit { get; }

    /// <summary>
    /// Normally set to <see cref="MustBe.Any"/> and has no effect.
    /// When set to <see cref="MustBe.Zero"/> or <see cref="MustBe.Ones"/>, it overrides the behavior of the field's 
    /// bits on write and during conversion of the underlying BitFields struct to/from other types.
    /// </summary>
    public MustBe ValueOverride { get; } = MustBe.Any;

    /// <summary>
    /// An optional human-readable description of this field.
    /// When <see cref="DescriptionResourceType"/> is null, this is a literal string.
    /// When <see cref="DescriptionResourceType"/> is set, this is a resource key
    /// resolved at runtime via the resource type's <c>ResourceManager</c>.
    /// </summary>
    /// <example>
    /// <code>
    /// // Literal description (no localization)
    /// [BitField(0, 3, Description = "IP header version")]
    /// public partial byte Version { get; set; }
    ///
    /// // Localized description via .resx resource file
    /// [BitField(0, 3, Description = nameof(Strings.IpVersion),
    ///                DescriptionResourceType = typeof(Strings))]
    /// public partial byte Version { get; set; }
    /// </code>
    /// </example>
    public string? Description { get; set; }

    /// <summary>
    /// When set, <see cref="Description"/> is treated as a resource key and resolved
    /// at runtime via this type's <c>ResourceManager</c> property.
    /// The type must have a static <c>ResourceManager</c> property (as generated by .resx files).
    /// </summary>
    public Type? DescriptionResourceType { get; set; }

    /// <summary>
    /// Creates a new bit field attribute with Rust-style inclusive bit range.
    /// </summary>
    /// <param name="startBit">The starting bit position (0-based, inclusive).</param>
    /// <param name="endBit">The ending bit position (0-based, inclusive). Must be >= startBit.</param>
    /// <param name="mustBe">Optional override for how bits are handled for this field. Defaults to <see cref="MustBe.Any"/>.
    /// If set to <see cref="MustBe.Zero"/>, the bits will be masked to zero on write. If set to
    /// <see cref="MustBe.Ones"/>, the bits will be set to one on write.
    /// <exception cref="ArgumentException">Thrown when endBit is less than startBit.</exception>
    public BitFieldAttribute(int startBit, int endBit, MustBe mustBe = MustBe.Any)
    {
        if (endBit < startBit)
            throw new ArgumentException($"endBit ({endBit}) must be >= startBit ({startBit})", nameof(endBit));

        StartBit = startBit;
        EndBit = endBit;
        ValueOverride = mustBe;
    }
}
